[
  {
    "FrontMatter": {
      "title": "Leveraging AI Embeddings for Related Content Classification",
      "short_title": "AI Embeddings for Related Content in Hugo",
      "description": "Explores using AI embeddings and cosine similarity to improve related content recommendations in Hugo, enhancing semantic relevance, user navigation, and AI discoverability efficiently.",
      "tldr": "Switching from Hugo’s basic related content feature to an AI embeddings-based approach enabled much more accurate and meaningful content recommendations, improving both user navigation and AI discoverability. The solution was cost-effective, scalable, and reduced computational overhead by caching similarity scores and storing embeddings for reuse. Development managers can consider using AI embeddings for smarter content linking, which can enhance user experience and support future automation or classification needs.",
      "date": "2025-06-04T09:00:00Z",
      "lastmod": "2025-06-04T09:00:00Z",
      "weight": 565.0,
      "sitemap": {
        "filename": "sitemap.xml",
        "priority": 0.3,
        "changefreq": "weekly"
      },
      "ResourceId": "OUeioY0BIV-",
      "ResourceImport": false,
      "ResourceType": "engineering-notes",
      "ResourceContentOrigin": "human",
      "slug": "leveraging-ai-embeddings-for-related-content-classification",
      "aliases": [
        "/resources/OUeioY0BIV-"
      ],
      "concepts": [
        "Tool"
      ],
      "categories": [
        "Uncategorized"
      ],
      "tags": [
        "Technical Mastery",
        "Artificial Intelligence",
        "Miscellaneous"
      ],
      "Watermarks": {
        "description": "2025-05-28T11:53:29Z",
        "short_title": "2025-07-07T16:43:44Z",
        "tldr": "2025-08-07T12:11:54Z"
      }
    },
    "BodyContent": "Mid-last year, I transitioned my website to Hugo and since then have been exploring AI-driven content classification. A common feature I have always appreciated is the \"related content\" recommendation, suggesting to readers what's next or what else might be of interest. Although Hugo’s built-in related content functionality is perfectly serviceable, relying on parameters like tags, keywords, and headings, I believed there was room for something more sophisticated.\n\nIn general, for my site, my focus has shifted towards Generative Experience Optimisation (GEO), aiming to enhance the reading experience for both humans and generative AI agents. Unlike traditional Search Engine Optimisation (SEO), GEO optimises content readability and semantic relevance, creating a win-win scenario for both humans and AI. SEO often prioritises keyword density, sometimes compromising readability. GEO, conversely, optimises content clarity for both human understanding and AI comprehension. With this shift, the standard method in Hugo,though efficient for basic needs,felt insufficient.\n\nThe challenge was clear: Hugo's built-in related content system, based on static parameters, lacked semantic understanding. It didn't recognise deeper contextual relationships between articles beyond shared tags or keywords.\n\nI initially considered leveraging my existing classification capabilities, but the computation involved would be excessive, approximately 2.56 million API calls for my content catalogue, an impractical approach that would be very expensive and slow.\n\n## Creating an Embeddings Repository\n\nInstead, I opted for a more fun, computationally efficient method: OpenAI Embeddings. Embeddings convert textual content into numerical vectors, capturing semantic meaning and enabling sophisticated comparisons.\n\nThe power of embeddings lies in their semantic understanding. Rather than purely lexical comparisons, embeddings identify relationships in meaning. This makes them perfect for establishing truly relevant connections between articles.\n\n![Cost](images/2025-05-28_11-12-14.jpg)\n\nThe first step was to generate embeddings for each piece of content using OpenAI's Embeddings API. The cost-efficiency of this method was striking; I generated embeddings for around 1,600 content pieces (about 3,876 requests, including debugging) at a minimal total cost of \\$0.66.\n\n```powershell\nfunction Get-OpenAIEmbedding {\n    param (\n        [Parameter(Mandatory)]\n        [string]$Content,\n\n        [string]$Model = \"text-embedding-3-large\",\n        # OpenAI API Key\n        [string]$OPEN_AI_KEY = $env:OPENAI_API_KEY\n    )\n\n    $response = Invoke-RestMethod `\n        -Uri \"https://api.openai.com/v1/embeddings\" `\n        -Headers @{\n        \"Authorization\" = \"Bearer $OPEN_AI_KEY\"\n        \"Content-Type\"  = \"application/json\"\n    } `\n        -Body (ConvertTo-Json @{\n            input = $Content\n            model = $Model\n        }) `\n        -Method Post\n\n    return $response.data[0].embedding\n}\n```\n\nTo manage these embeddings efficiently, I stored them locally and synced them to Azure Blob Storage, creating a reusable, easily accessible repository. Although the cost was minimal the runtime to get the embedding for 1600 items was non-trivial so I syncing them to cloud storage to significantly reduces processing time for future operations.\n\n![Azure Blob Storage](images/2025-05-28_11-14-09.jpg)\n\nAZCopy is your friend here as it's able to minimise the upload/download time.\n\n## Calculating Cosine Similarity\n\nWith the embeddings in place, the next task was to calculate the semantic similarity between content items using Cosine Similarity. This algorithm measures the angle between two embedding vectors, returning a similarity score ranging from -1 (completely opposite) to 1 (identical).\n\n```powershell\nfunction Get-EmbeddingCosineSimilarity {\n    param (\n        [float[]]$VectorA,\n        [float[]]$VectorB\n    )\n\n    $dotProduct = 0\n    $magnitudeA = 0\n    $magnitudeB = 0\n\n    for ($i = 0; $i -lt $VectorA.Length; $i++) {\n        $dotProduct += $VectorA[$i] * $VectorB[$i]\n        $magnitudeA += [Math]::Pow($VectorA[$i], 2)\n        $magnitudeB += [Math]::Pow($VectorB[$i], 2)\n    }\n\n    if ($magnitudeA -eq 0 -or $magnitudeB -eq 0) {\n        return 0\n    }\n\n    return $dotProduct / ([Math]::Sqrt($magnitudeA) * [Math]::Sqrt($magnitudeB))\n}\n```\n\nThis step was computationally intensive due to comparing each content item against all others. To manage this, I cached similarity scores above a threshold (0.5 or higher), significantly reducing future computations.\n\n```powershell\n{\n  \"calculatedAt\": \"2025-05-27T18:44:01.8272803Z\",\n  \"related\": [\n    {\n      \"Title\": \"Mastering Azure DevOps Migration: Navigating Challenges, Solutions, and Best Practices\",\n      \"Slug\": \"mastering-azure-devops-migration-navigating-challenges-solutions-and-best-practices\",\n      \"Reference\": \"resources/videos/youtube/_rJoehoYIVA\",\n      \"ResourceType\": \"videos\",\n      \"ResourceId\": \"_rJoehoYIVA\",\n      \"Similarity\": 0.6808168645512461\n    },\n    {\n      \"Title\": \"Mastering Azure DevOps Migration: A Step-by-Step Guide for Seamless Project Transfers\",\n      \"Slug\": \"mastering-azure-devops-migration-a-step-by-step-guide-for-seamless-project-transfers\",\n      \"Reference\": \"resources/videos/youtube/Qt1Ywu_KLrc\",\n      \"ResourceType\": \"videos\",\n      \"ResourceId\": \"Qt1Ywu_KLrc\",\n      \"Similarity\": 0.6715379090446947\n    },\n    {\n      \"Title\": \"Navigating the TFS to Azure DevOps Migration: Overcoming Compatibility Concerns with Confidence\",\n      \"Slug\": \"navigating-the-tfs-to-azure-devops-migration-overcoming-compatibility-concerns-with-confidence\",\n      \"Reference\": \"resources/videos/youtube/qpo4Ru1VVZE\",\n      \"ResourceType\": \"videos\",\n      \"ResourceId\": \"qpo4Ru1VVZE\",\n      \"Similarity\": 0.6701177401809448\n    }\n  ]\n}\n```\n\nThis is then stored with the content item and used to get the related content items for any specific content item.\n\n## Integration into Hugo Layout\n\nWith similarity scores computed and cached, integrating them into Hugo was straightforward. I updated the Hugo layout to dynamically load the cached similarity scores at build-time, displaying the top 3 related content items for each article. This provided a more meaningful user experience without excessive runtime overhead.\n\n![Related Content Example](images/2025-05-28_11-03-57.jpg)\n\n## The Outcomes\n\nThe impact of this all remains to be seen, but there is an expectation that beyond the usability enhancements that this brings for human readers, it will also bring enhancements to content analysis by AI agents. These links enable the discoverability of other actually related content which should tickle the AI search algorithms to promote the content more.\n\nThe implementation was remarkably successful:\n\n- Enhanced semantic relevance significantly improved user navigation and AI discoverability\n- Dramatically reduced computation costs and improved build performance.\n- Established a scalable, reusable embeddings infrastructure for future use cases.\n\nAs I mentioned, the impact remains to be seen, and I have no idea how often AI crawls the content for updates. However, this will be live on my site by the time you read this.\n\n## Future Improvements and Extensions\n\nIf this experiment proves to be successful, there are a number of other ideas that I have for its use:\n\n- **Crosslink Automation**: Embedding dynamic crosslinks directly within article content, enhancing internal linking strategies. This data would allow me to pick, say, the top 3 most relevant contact items and use a semantic call to inject the links on relevant content..\n- **Classification Filtering**: Using embeddings to pre-filter classification tasks, significantly reducing ongoing costs. Instead of making 160 expensive calls to AI for a new post, I can run this first and find the ones that are more likely to be valuable.\n\n## Conclusion\n\nUsing embeddings to enhance related content has provided a practical and scalable improvement to my site's content classification. It aligns perfectly with my goal of optimising the experience for both human readers and AI systems. While the true impact of this approach will become clearer over time, the initial implementation already shows significant promise for improving relevance and efficiency.\n",
    "FilePath": "C:\\Users\\MartinHinshelwoodNKD\\source\\repos\\NKDAgility.com\\site\\content\\resources\\engineering-notes\\2025-06-04-leveraging-ai-embeddings-for-related-content-classification\\index.md",
    "FolderPath": "C:\\Users\\MartinHinshelwoodNKD\\source\\repos\\NKDAgility.com\\site\\content\\resources\\engineering-notes\\2025-06-04-leveraging-ai-embeddings-for-related-content-classification",
    "ReferencePath": "resources/engineering-notes/2025-06-04-leveraging-ai-embeddings-for-related-content-classification"
  },
  {
    "FrontMatter": {
      "title": "Convert Legacy Projects and ASP.NET MVC Apps to SDK-Style with Confidence",
      "short_title": "Convert Legacy .NET and ASP.NET MVC to SDK-Style",
      "description": "Learn how to upgrade legacy .NET and ASP.NET MVC projects to SDK-style for easier builds, modern tooling, and future readiness, including tips for class libraries and web apps.",
      "tldr": "Upgrading legacy .NET projects to SDK-style makes your codebase easier to maintain, improves build and CI/CD integration, and prepares you for future .NET upgrades. Converting class libraries is straightforward and highly recommended, while web apps require more care and are best handled with the MSBuild.SDK.SystemWeb package if you want SDK-style; otherwise, you can leave them in the old format. Start by converting class libraries now to simplify your engineering system and reduce technical debt.",
      "date": "2025-05-29T09:00:00Z",
      "lastmod": "2025-05-29T09:00:00Z",
      "weight": 350.0,
      "sitemap": {
        "filename": "sitemap.xml",
        "priority": 0.6,
        "changefreq": "weekly"
      },
      "ResourceId": "2mdv7QE2nIt",
      "ResourceImport": false,
      "ResourceType": "engineering-notes",
      "ResourceContentOrigin": "human",
      "slug": "convert-legacy-projects-and-asp-net-mvc-apps-to-sdk-style-with-confidence",
      "aliases": [
        "/resources/2mdv7QE2nIt"
      ],
      "concepts": [
        "Tool"
      ],
      "categories": [
        "Engineering Excellence"
      ],
      "tags": [
        "Install and Configuration",
        "Software Development",
        "Pragmatic Thinking",
        "Technical Mastery",
        "System Configuration",
        "Engineering Practices",
        "Operational Practices",
        "Troubleshooting",
        "Application Lifecycle Management"
      ],
      "Watermarks": {
        "description": "2025-05-07T15:00:14Z",
        "short_title": "2025-07-07T16:43:54Z",
        "tldr": "2025-08-07T12:29:17Z"
      }
    },
    "BodyContent": "I’ve been working with a customer who, like many, is stuck in the past. They were on Team Foundation Version Control (TFVC), and the backbone of their application is .NET 4.5. This creates real problems for modern engineering practices because many new tools just won’t work, so I am moving to Git, and as part of that looking to ensure that their setup is future ready. I also need to do something with all those peskie legacy DLLs that are scattered around the solution. One of the key upgrades I was looking at is moving to SDK-style projects. This is a big deal because it’s the future of .NET development, and it’s a lot easier to work with than the old project format.\n\nThe good news: you can move to SDK-style projects even if you’re targeting older .NET versions.\n\nFor the Azure DevOps Migration Tools, a contributor did the upgrade, and the capabilities are outstanding:\n\n- Simpler project file format – no more messy MSBuild clutter\n- Supports `Directory.Build.props` to consolidate configuration across the solution\n- Supports `Directory.Packages.props` to consolidate NuGet versions and avoid DLL hell\n- Builds with `dotnet build` (your mileage may vary)\n\nAdditional reasons to move to SDK-style projects:\n\n- Easier multi-targeting support\n- Better integration with modern CI/CD pipelines\n- Cleaner diffs in source control\n- Consistent experience across .NET Core, .NET 5+, and .NET Framework\n- Improved support for analyzers and code quality tools\n- Faster restore and build times in many cases\n\nThe Azure DevOps Migration Tools combine class libraries and executables, with a mix of .NET 4.8.1, netstandard2.0, and net8.0 – they all have to interoperate smoothly.\n\nSDK-style `.csproj` files simplify your build system, cut the clutter, and prepare you for future upgrades. Here’s the pragmatic reality: Microsoft does not officially support converting classic ASP.NET MVC/WebForms projects to SDK-style. Class libraries? Straightforward. Web apps? That takes discipline, skill, and a willingness to dive into the details. With the right approach, you can absolutely get this working and keep IIS Express debugging alive.\n\nLet’s break it down with radical clarity.\n\n## Class Library Conversion – No-Brainer\n\nClass libraries are the easy win. They have minimal impact on code but make it massively easier to organise and maintain.\n\n- Use .NET Upgrade Assistant or `try-convert`\n  Automate the rewrite:\n\n  ```shell\n  try-convert -p YourProject.csproj --keep-current-tfms --no-backup\n  ```\n\n  This keeps you on `net481` but upgrades the project format.\n\n- Manual option if you want full control:\n\n  ```xml\n  <Project Sdk=\"Microsoft.NET.Sdk\">\n    <PropertyGroup>\n      <TargetFramework>net481</TargetFramework>\n    </PropertyGroup>\n  </Project>\n  ```\n\n- Switch from `packages.config` to `<PackageReference>`\n  Drop the legacy baggage.\n\n- Test thoroughly. Rebuild, run tests, and make sure everything resolves. This is not the time to skip CI.\n\nIn my experience, the \"right-click on project\" → Upgrade option in Visual Studio also works well.\n\n## ASP.NET MVC/WebForms Conversion – Tread Carefully\n\nThis is where it gets tricky. There’s no official support for MVC/WebForms in SDK projects, and it’s like wrestling a bear to get it all working.\n\nThere are two practical approaches:\n\n### 1. Use the Community MSBuild SDK (Recommended)\n\n- Convert with:\n\n  ```shell\n  try-convert -p YourWebApp.csproj --keep-current-tfms --no-backup --force-web-conversion\n  ```\n\n- Change the SDK line:\n\n  ```xml\n  <Project Sdk=\"MSBuild.SDK.SystemWeb/4.0.97\">\n  ```\n\nWhy this works:\n\n- Adds the missing web build magic (`System.Web`, Razor, content files)\n- Supports F5 debugging, publishing, transforms\n- Keeps you close to classic Visual Studio behaviour\n\nKeep an eye on [MSBuild.SDK.SystemWeb on GitHub](https://github.com/CZEMacLeod/MSBuild.SDK.SystemWeb) for updates.\n\n### 2. Manual Tweaks Without External SDK\n\n- Set the output correctly:\n\n  ```xml\n  <OutputType>Library</OutputType>\n  <OutputPath>bin\\</OutputPath>\n  <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>\n  ```\n\n- Define the run command:\n\n  ```xml\n  <RunCommand>$(MSBuildExtensionsPath64)\\..\\IIS Express\\iisexpress.exe</RunCommand>\n  <RunArguments>/path:\"$(MSBuildProjectDirectory)\" /port:YOUR_PORT</RunArguments>\n  ```\n\n- Check or add launchSettings.json, but note that Visual Studio often ignores it without the `RunCommand` fix.\n\nRecommendation: Don’t waste time fighting Visual Studio. Use SystemWeb SDK if you want a sustainable setup.\n\n## Debugging Survival Guide\n\nDebugging can be a pain, and in complex apps, it’s still hit-or-miss. But here’s what typically works:\n\nIf you get the \"RunCommand not set\" error, add `<RunCommand>` and `<RunArguments>` in your .csproj. This tells Visual Studio how to launch IIS Express.\n\nIf you see the “Debugging Release build” warning, go to Project > Build and uncheck “Optimize code” in Debug. Also, confirm `<Optimize>false</Optimize>` is set in the .csproj and do a full clean and rebuild.\n\nIf you’re attaching to a running process, enable “Suppress JIT optimization on module load” in the Visual Studio debugging options. This will let you step through code without the headache of optimized binaries.\n\nFinally, check that your PDB files are loaded. Open the Modules window during debugging and make sure the symbols are picked up from your output directory. Without them, breakpoints won’t bind, and you’re debugging blind.\n\n## Known Limitations\n\nSome things just won’t come back. The \"Web\" tab in the project properties is gone, but you can configure everything you need using the .csproj and launchSettings.\n\nOut-of-the-box publish won’t work because it expects a .NET 5+ project. You’ll need to script your own publish steps to get the bits into the right place.\n\nIf needed, you can leave web apps in the old format and just convert the class libraries. That’s a pragmatic call if you’re not planning to touch System.Web long-term.\n\n## Final Recommendations\n\nHere’s where it all comes together. These are the pragmatic, no-nonsense calls you should make after working through the conversion process.\n\n- Convert class libraries: Yes, immediately.\n- Convert web apps:\n\n  - Use MSBuild.SDK.SystemWeb if you want SDK-style.\n  - Skip if you’re staying on .NET Framework and want zero friction.\n\nThe point of this work isn’t to show off modern `.csproj` files. It’s to make your engineering system simpler, more maintainable, and ready for what’s next.\n",
    "FilePath": "C:\\Users\\MartinHinshelwoodNKD\\source\\repos\\NKDAgility.com\\site\\content\\resources\\engineering-notes\\2025-05-28-convert-legacy-projects-aspnet-mvc-to-sdk-style\\index.md",
    "FolderPath": "C:\\Users\\MartinHinshelwoodNKD\\source\\repos\\NKDAgility.com\\site\\content\\resources\\engineering-notes\\2025-05-28-convert-legacy-projects-aspnet-mvc-to-sdk-style",
    "ReferencePath": "resources/engineering-notes/2025-05-28-convert-legacy-projects-aspnet-mvc-to-sdk-style"
  },
  {
    "FrontMatter": {
      "title": "How I Used Generative AI to Transform Site Tagging and Categories",
      "short_title": "Generative AI for Automated Site Tagging",
      "description": "Explains how generative AI and PowerShell scripts automate and improve blog post tagging and categorisation in Hugo, with human oversight and transparent audit trails.",
      "tldr": "Migrating a large, legacy blog to Hugo enabled the use of generative AI for automated tagging and categorisation, significantly improving content discoverability and editorial consistency while reducing manual effort. The system combines AI-driven suggestions with human oversight, using multi-factor scoring, penalty logic, and transparent reasoning to ensure quality and accountability. Development managers considering similar automation should maintain human control over final decisions and leverage AI to streamline, not replace, editorial processes.",
      "date": "2025-05-15T09:00:00Z",
      "lastmod": "2025-05-15T09:00:00Z",
      "weight": 470.0,
      "sitemap": {
        "filename": "sitemap.xml",
        "priority": 0.4,
        "changefreq": "weekly"
      },
      "ResourceId": "oRStCAqLAY4",
      "ResourceImport": false,
      "ResourceType": "engineering-notes",
      "ResourceContentOrigin": "human",
      "slug": "how-i-used-generative-ai-to-transform-site-tagging-and-categories",
      "aliases": [
        "/resources/oRStCAqLAY4"
      ],
      "concepts": [
        "Tool"
      ],
      "categories": [
        "Uncategorized"
      ],
      "tags": [
        "Artificial Intelligence",
        "Personal",
        "Software Development",
        "Technical Mastery",
        "Transparency",
        "Pragmatic Thinking",
        "Agentic Engineering"
      ],
      "Watermarks": {
        "description": "2025-05-07T13:48:01Z",
        "short_title": "2025-07-07T16:44:11Z",
        "tldr": "2025-08-07T12:32:16Z"
      }
    },
    "BodyContent": "I moved my blog to Hugo in mid-2024 to regain control over my content and workflow. This proved to be a great decision as it gave me the ability to really focus on content for my site.\n\nMy site has been around since 2006 and was originally on GeeksWithBlogs, then Blogger, and then WordPress. As it moved, it grew in complexity, but updating legacy things like \"old posts\" and \"categories\" became painful in WordPress when you have 800+ posts. If you have tried to use the WordPress API, you will understand the pain.\n\nSo when I moved, I wanted my content to be portable, static, and in a data format that I could easily manipulate. I chose Hugo as the site generator, with Markdown and YAML as the data formats (with some JSON as you will see below). This made it very easy to write scripts over the top of the Markdown and update it dynamically. I built a bunch of such scripts, and it became apparent very early that AI could play a fantastic part in the story. My first implementation of AI was to use a prompt to ensure that my posts all had an SEO-friendly description. This worked great and produced some fantastic descriptions, but while it’s tempting to treat AI as a black box, that’s reckless. AI systems have **agency**, but it is limited to **tactical optimisation** — they can suggest, rank, and cluster, but they cannot **own accountability** for what gets published or accepted. That’s the human’s job.\n\nThis post outlines the architecture and technical strategy I implemented to integrate OpenAI into my Hugo site for automated classification, while maintaining human oversight and ensuring auditability.\n\n### Why I Built This\n\nI realised pretty quickly that many of my tags and categories were vague, uninteresting, and often just wrong. I had over 1,000 tags and 200 categories, which made discoverability a nightmare. So I decided to see if I could leverage generative AI to do the classification for me once I had pruned my categorisations.\n\nI finally ended up with about 140 tags and 12 categories, but more recently also introduced the idea of \"Concepts\" to classify the classifications — what fun.\n\nOverall I wanted to:\n\n- **Improve discoverability** across hundreds of blog posts.\n- **Align tags and categories** with consistent editorial standards.\n- **Reduce manual labour** but keep ultimate control in human hands.\n- **Make classification decisions traceable and explainable.**\n\nAutomation without traceability is irresponsible. This system deliberately blends machine suggestions with deterministic validation and penalty logic to ensure reliable, explainable outcomes.\n\nWhile I started with just a dump of my 19 years of categories and tags, over that time I had moved from a web developer through DevOps and Scrum to a process consultant. As you can imagine, the context of the taxonomies and their intent changed a lot over time. I needed to really think about what I wanted for each, and the new classification system relies on three interconnected layers:\n\n- **Concepts** → High-level thematic anchors that describe foundational ideas (e.g., Philosophy, Practices, Methods, Values, Strategy). These are used to \"classify the classifications.\"\n- **Categories** → Editorially curated groupings that organise posts into broad topic clusters aligned with user needs (e.g., Technical Leadership, Product Development, Scrum, Kanban). Some tags are promoted to categories for marketing purposes.\n- **Tags** → Detailed, fine-grained descriptors that capture specific topics, techniques, tools, or patterns (e.g., Scrum Mastery, CI/CD, Azure Pipelines).\n\nBy combining these, I created a multi-level structure that improves searchability, recommendation accuracy, and editorial consistency. Tags have categories, and both tags and categories have concepts. I think of tags and categories as a single list, but categories are few, important, and go at the top of the content, and tags are many, tactical, and go at the bottom.\n\nThe AI assigns tags, categories, and concepts to all the content items using \"instructions\" embedded in the classification pages.\n\nI'm a Windows user and have been for years, so I wrote all of the scripting in PowerShell. For me, this is the most flexible as it’s native, and anything I can’t do in PowerShell I can use C#. I do have some calls out to Python, but that’s another post. Iterating over a bunch of Markdown files with YAML front matter is a trivial experience, but I have built up a bunch of helper modules over the last 6 months that do a lot of the heavy lifting — so much so that it can take minutes to build new scripts for specific one-time tasks. For example, if I want to get a list of all my content resources pre-parsed into an ordered front matter hashtable and the content, then all I need to do is call `$hugoMarkdownObjects = Get-RecentHugoMarkdownResources -Path \".\\site\\content\\resources\\\" -YearsBack 1` and I have a ready-to-iterate collection.\n\nI also have a batch version, and all of my code is in GitHub where it can be versioned, branched, and reviewed with a PR.\n\n## How it Works\n\nI created a JSON cache format to reliably store the results from OpenAI. This design gives me a structured, reusable data layer that feeds the rest of the system with clean, consistent inputs. Initially, I tried creating a prompt with a list of all 160 tags and categories and asking the AI to select them, but that created a bunch of junk.\n\nUltimately, I settled on a single call for each classification that tested that classification against the content, based on clear instructions from the classification front matter. The result is that for each piece of content and every classification, I have an entry in the cache file that looks like:\n\n### Example Output\n\n```json\n{\n  \"Technical Leadership\": {\n    \"resourceId\": \"TwYNSm1pZOS\",\n    \"category\": \"Technical Leadership\",\n    \"calculated_at\": \"2025-05-05T13:24:31\",\n    \"ai_confidence\": 82.5,\n    \"ai_mentions\": 7.5,\n    \"ai_alignment\": 8.5,\n    \"ai_depth\": 8.0,\n    \"ai_intent\": null,\n    \"ai_audience\": 7.0,\n    \"ai_signal\": 8.0,\n    \"ai_penalties_applied\": false,\n    \"ai_penalty_points\": 0,\n    \"ai_penalty_details\": \"none\",\n    \"final_score\": 82.0,\n    \"reasoning\": \"The content discusses the Definition of Done (DoD) within the context of Scrum, which is a key aspect of agile methodologies. It directly addresses the importance of quality and transparency in software development, aligning well with the principles of technical leadership. The explicit mention of the DoD and its role in ensuring quality reflects a strong understanding of servant leadership and accountability within teams. The content thoroughly explores the implications of having a DoD, including its impact on team dynamics, accountability, and continuous improvement, which are all relevant to technical leadership. The intent is clearly to inform and guide teams on best practices, making it suitable for the target audience of technical leaders and practitioners. The signal-to-noise ratio is high, with minimal off-topic content, focusing instead on actionable insights and strategies for implementing a robust DoD. Overall, the content fits well within the category of Technical Leadership, meriting a high confidence score.\",\n    \"level\": \"Primary\"\n  }\n}\n```\n\nThis creates a bunch of scores from 0–10 in Mentions, Alignment, Depth, Intent, Audience, and Signal. It assesses penalties and creates a final score, out of 100, that represents how confident the AI is that it matches.\n\n### AI + Human Oversight\n\nAI here has **no editorial authority**. It supplies **probabilistic suggestions**. I maintain control using a mixture of content manipulation and reviewing the output, while the human-authored penalty and validation layers provide **deterministic enforcement**. This distinction is non-negotiable. AI is a tactical agent, not a strategic decision-maker.\n\nThis reflects the ethos outlined in [Human and AI Agency in Adaptive Systems](https://preview.nkdagility.com/resources/ffJaR9AaTl7): **humans set direction and own accountability; AI optimises within defined boundaries**.\n\n## Technical Strengths\n\nI've been very impressed with the capability, and I’ve also learned valuable lessons about where AI shines and where human judgment is indispensable. Every classification has a clear reason for being attached to the content that’s reviewable and transparent. I even use the reasoning on the site.\n\n- Quantitative, multi-factor assessment.\n- Penalty and validation rules strengthen match quality.\n- Human-readable reasoning baked into outputs.\n- Cached results reduce API calls and speed up builds.\n- Seamless integration into Hugo’s version-controlled structure.\n\n### Future Enhancements\n\n- Track classification shifts over time.\n- Introduce ensemble AI models for cross-validation.\n- Add a human review loop to feed corrections back into system tuning.\n- Build a site-wide dashboard showing confidence trends, penalty patterns, and overall classification health.\n\n## Closing Thoughts\n\nBringing AI into this system has been transformative, and if you’re considering similar work, my advice is simple: don’t delegate accountability — use AI to amplify your judgment. By combining automation with careful oversight, I’ve turned a massive manual maintenance burden into a scalable, transparent process. This work has not only improved the quality and consistency of my site, but it has also deepened my own understanding of how to use AI responsibly: as a partner in execution, not as a substitute for accountability. I’m excited about where this will go next and how it can push the boundaries of what’s possible in content management.\n",
    "FilePath": "C:\\Users\\MartinHinshelwoodNKD\\source\\repos\\NKDAgility.com\\site\\content\\resources\\engineering-notes\\2025-05-15-generative-ai-for-classifications\\index.md",
    "FolderPath": "C:\\Users\\MartinHinshelwoodNKD\\source\\repos\\NKDAgility.com\\site\\content\\resources\\engineering-notes\\2025-05-15-generative-ai-for-classifications",
    "ReferencePath": "resources/engineering-notes/2025-05-15-generative-ai-for-classifications"
  },
  {
    "FrontMatter": {
      "title": "Building a Resilient Token Server: Engineering for Flow, Fault Tolerance, and Speed",
      "short_title": "Building a Resilient Token Server for Fault Tolerance",
      "description": "Explains how to engineer a robust, fault-tolerant token counting server using FastAPI and PowerShell, covering error handling, retries, fallbacks, and resilient workflows.",
      "tldr": "Aiming for a resilient, fast, and fault-tolerant token counting system, the author replaced fragile server restarts with a batch-wide server lifecycle, added retry logic for transient failures, and implemented a local fallback to ensure uninterrupted processing. These changes improved reliability, reduced downtime, and provided clear logs for troubleshooting. Development managers should focus on building systems that handle real-world failures gracefully, prioritize flow, and include observability and fallback mechanisms from the start.",
      "date": "2025-05-08T09:00:00Z",
      "lastmod": "2025-05-08T09:00:00Z",
      "weight": 255.0,
      "sitemap": {
        "filename": "sitemap.xml",
        "priority": 0.6,
        "changefreq": "weekly"
      },
      "ResourceId": "mjsboLP-N9P",
      "ResourceImport": false,
      "ResourceType": "engineering-notes",
      "ResourceContentOrigin": "human",
      "slug": "building-a-resilient-token-server-engineering-for-flow-fault-tolerance-and-speed",
      "aliases": [
        "/resources/mjsboLP-N9P"
      ],
      "concepts": [
        "Tool"
      ],
      "categories": [
        "Engineering Excellence",
        "DevOps"
      ],
      "tags": [
        "Technical Mastery",
        "Pragmatic Thinking",
        "Software Development",
        "Operational Practices",
        "Troubleshooting",
        "Personal",
        "Continuous Improvement",
        "Engineering Practices",
        "Working Software",
        "Technical Excellence",
        "Site Reliability Engineering",
        "System Configuration"
      ],
      "Watermarks": {
        "description": "2025-05-07T12:49:10Z",
        "short_title": "2025-07-07T16:44:24Z",
        "tldr": "2025-08-07T12:32:42Z"
      }
    },
    "BodyContent": "Modern engineering is about making sure systems keep running reliably under load, failure, and unpredictable conditions. When I set out to build a fast, dependable way to calculate OpenAI token counts for my batch classification pipeline, I didn’t want a quick script or a one-off tool. I wanted a **resilient, observable, fault-tolerant system** that fit tightly into my PowerShell-first workflow and could hold up in real conditions, not just lab tests.\n\n**Background:** Midway through last year, I finally accepted that WordPress was no longer the future for me. To be honest, I’d known it for a while, but the pain of migrating was bigger than the pain of sticking with it—until it wasn’t. I made the deliberate choice to rebuild a decade of Wordpress content into Hugo, Markdown, YAML, and a layer of PowerShell automation for bulk editing. As I ramped up automation for pre-processing and OpenAI-driven bulk edits, one bottleneck hit hard: counting tokens. I had an existing method calling out to Python from PowerShell, but it clocked in at around five minutes per thousand prompts. That was unacceptable for the scale I wanted.\n\nThis post lays out exactly how I tackled that challenge—what worked, what fell apart, and how I hardened the system into something that performs reliably under real-world pressure, or at least \"my world\" pressure.\n\n## Starting Line: What I Set Out to Build\n\n- A Python FastAPI server (`token_server.py`) to expose token counting as a REST API.\n- A PowerShell wrapper (`TokenServer.ps1`) to orchestrate batch calls and control the server lifecycle.\n- Seamless integration into our `Update-ResourcesClassificationsBatch.ps1` script, which feeds Hugo markdown files for token counting.\n\nSounds simple? Not so fast.\n\n## Where It Fell Apart\n\nHere’s where the early implementation hit the wall:\n\n- Repeated server restarts led to **Windows port binding errors** (`Only one usage of each socket address...`).\n- Sockets sat in `TIME_WAIT`, leaving the system **unable to reuse ports quickly**.\n- PowerShell orchestration assumed the server was either always running or needed a restart; both assumptions failed under load. We were processing \\~30k prompts, and it failed at about 6k.\n- Failure detection (`Test-TokenServer`) was **too aggressive**, flagging false negatives and triggering unnecessary restarts.\n\nIn short, the system had no resilience. It worked when everything was perfect and collapsed under even minor hiccups. That’s not engineering; that’s gambling.\n\nIt did get to the end of its run, but the logs told the real story, which is why I included the relevant segment here. Logs are not fluff or noise; they are the raw, transparent evidence that shows what really happened, reinforcing my ethos of engineering honesty and accountability, even when things get messy. The real story of errors and flakiness:\n\n```bash\n[11:38:27 INF] Starting Token Server on 127.0.0.1:8000 using script .\\.powershell\\py\\token_server.py\n[11:38:37 INF] Token Server is now running at 127.0.0.1:8000\n[11:38:41 INF] 1521 prompts Built for 9 of 169 markdown files (5%)\n[11:38:48 INF] 2843 prompts Built for 17 of 169 markdown files (10%)\n[11:38:54 INF] 4229 prompts Built for 26 of 169 markdown files (15%)\n[11:39:01 INF] 5476 prompts Built for 34 of 169 markdown files (20%)\n[11:39:09 INF] 6862 prompts Built for 43 of 169 markdown files (25%)\n[11:39:18 INF] Token Server already responding at 127.0.0.1:8000\n[11:39:18 ERR] Failed to get token count from server: Only one usage of each socket address (protocol/network address/port) is normally permitted. (127.0.0.1:8000)\n[11:39:24 INF] Stopping Token Server with tracked PID 13536\n[11:39:24 INF] Starting Token Server on 127.0.0.1:8000 using script .\\.powershell\\py\\token_server.py\n[11:39:25 INF] Token Server is now running at 127.0.0.1:8000\n[11:39:25 ERR] Failed to get token count from server: Only one usage of each socket address (protocol/network address/port) is normally permitted. (127.0.0.1:8000)\n[11:39:29 INF] Token Server already responding at 127.0.0.1:8000\n[11:39:29 ERR] Failed to get token count from server: Only one usage of each socket address (protocol/network address/port) is normally permitted. (127.0.0.1:8000)\n[11:39:32 INF] Token Server already responding at 127.0.0.1:8000\n[11:39:32 ERR] Failed to get token count from server: Only one usage of each socket address (protocol/network address/port) is normally permitted. (127.0.0.1:8000)\n[11:39:34 ERR] Failed to get token count from server: Only one usage of each socket address (protocol/network address/port) is normally permitted. (127.0.0.1:8000)\n[11:39:40 INF] Stopping Token Server with tracked PID 121896\n[11:39:40 INF] Starting Token Server on 127.0.0.1:8000 using script .\\.powershell\\py\\token_server.py\n[11:39:48 INF] Token Server is now running at 127.0.0.1:8000\n[11:39:48 ERR] Failed to get token count from server: Only one usage of each socket address (protocol/network address/port) is normally permitted. (127.0.0.1:8000)\n[11:39:53 INF] Token Server already responding at 127.0.0.1:8000\n[11:39:54 ERR] Failed to get token count from server: Only one usage of each socket address (protocol/network address/port) is normally permitted. (127.0.0.1:8000)\n[11:39:56 INF] 8094 prompts Built for 51 of 169 markdown files (30%)\n[11:39:59 ERR] Failed to get token count from server: Only one usage of each socket address (protocol/network address/port) is normally permitted. (127.0.0.1:8000)\n[11:40:01 ERR] Failed to get token count from server: Only one usage of each socket address (protocol/network address/port) is normally permitted. (127.0.0.1:8000)\n[11:40:05 INF] Token Server already responding at 127.0.0.1:8000\n[11:40:06 ERR] Failed to get token count from server: Only one usage of each socket address (protocol/network address/port) is normally permitted. (127.0.0.1:8000)\n[11:40:12 INF] Stopping Token Server with tracked PID 234028\n[11:40:12 INF] Starting Token Server on 127.0.0.1:8000 using script .\\.powershell\\py\\token_server.py\n[11:40:13 INF] Token Server is now running at 127.0.0.1:8000\n[11:40:13 ERR] Failed to get token count from server: Only one usage of each socket address (protocol/network address/port) is normally permitted. (127.0.0.1:8000)\n[11:40:13 ERR] Failed to get token count from server: Only one usage of each socket address (protocol/network address/port) is normally permitted. (127.0.0.1:8000)\n[11:40:20 INF] Stopping Token Server with tracked PID 242448\n[11:40:20 INF] Starting Token Server on 127.0.0.1:8000 using script .\\.powershell\\py\\token_server.py\n[11:40:21 INF] Token Server is now running at 127.0.0.1:8000\n[11:40:27 INF] Stopping Token Server with tracked PID 232540\n[11:40:27 INF] Starting Token Server on 127.0.0.1:8000 using script .\\.powershell\\py\\token_server.py\n[11:40:37 INF] Token Server is now running at 127.0.0.1:8000\n[11:40:42 INF] 9480 prompts Built for 60 of 169 markdown files (35%)\n[11:40:50 INF] 10712 prompts Built for 68 of 169 markdown files (40%)\n```\n\nThis worked, but all the restarts made it painfully slow. However, to be clear, it was still faster than using local token calls.\n\n## Refactoring for Resilience\n\nHere’s exactly how I hardened the system once it was working, keeping everything pragmatic, outcome-focused, and fully aligned to the engineering ethos I follow — minimising errors, maximising resilience, and ensuring flow without cutting corners or adding unnecessary complexity.\n\n### Start/Stop Once Per Batch\n\nOriginally, I tried a model of \"start the server if it’s not running, and kill it if it faults,\" but that is what resulted in the errors above. Instead of cycling the server, I flipped to a **batch-wide lifecycle**:\n\n```powershell\nStart-TokenServer\n# Process all files here...\nStop-TokenServer\n```\n\nThis reduced port churn, avoided TIME_WAIT issues, and drastically simplified orchestration.\n\n### Add Retries Instead of Restarts\n\nFrom the log above, you can see I was trying to solve the fake-response problem by restarting the server — but that was the wrong approach. Restarting might hide symptoms, but it never fixes the underlying fragility. It always reminds me of that ridiculous video where someone rigged up a second server with a CD tray and taped a pencil to it so that when the first server stopped responding, the second one would eject its tray and physically press the reset button on the first. Sure, it technically works, but it’s the software equivalent of sweeping dirt under a rug. Engineering excellence means you address the real issues directly, not patch over them with hacks.\n\nInside `Get-TokenCountFromServer`, we wrapped the REST call in a retry loop:\n\n```powershell\nfor ($i = 0; $i -lt 3; $i++) {\n    try {\n        $response = Invoke-RestMethod -Uri $ServerUrl -Method Post -Body $body -ContentType \"application/json\" -TimeoutSec 10\n        return [int]$response.token_count\n    }\n    catch {\n        Start-Sleep -Seconds 1\n    }\n}\n```\n\nThis change turned transient network failures from system-breaking to non-events with barely noticeable delays. At scale, I would want proper back-off logic and probably apply a circuit breaker pattern, but here I kept it simple because it delivers what matters: stable, predictable flow without unnecessary overengineering.\n\n### Implement Local Fallback\n\nI already have logic to calculate the tokens locally and in isolation, which was the thing I wanted to refactor away. However, I realised that if the server was overloaded, I could either retry indefinitely, fail out, or regress to a local Python call. Sure, it was the slower path, but it acted as a deliberate, engineered fallback when the server stopped responding under load. This wasn’t just retries stacked on retries — it was a purposeful local option to guarantee the system would not fail completely and would keep moving, even if with a slight delay:\n\n```powershell\nfunction Get-TokenCountLocally {\n    param ([string]$Content)\n\n    $tempFile = [System.IO.Path]::GetTempFileName()\n    Set-Content -Path $tempFile -Value $Content -Encoding UTF8\n\n    $tokenCount = python -c @\"\nimport tiktoken, sys\nwith open(sys.argv[1], 'r', encoding='utf-8') as f:\n    text = f.read()\nencoding = tiktoken.get_encoding('cl100k_base')\nprint(len(encoding.encode(text)))\n\"@ $tempFile\n\n    Remove-Item $tempFile -Force\n    return [int]$tokenCount\n}\n```\n\n## Final System Outcomes\n\nBy the end, we delivered a system that:\n\n- Survives server restarts and network hiccups.\n- Automatically falls back to local processing if the server is down, giving it time to recover\n- Handles high-volume batch loads without choking.\n- Provides clear, observable logs for troubleshooting and improvement.\n\nThis is not just about counting tokens. It is about building resilient, fault-tolerant architectures that hold up under real-world use — and taking full ownership of the engineering outcome, even when the tool is 'just a script' for my own workflows. This reflects my principles as an engineer: if I touch it, I am accountable for its resilience, its clarity, and its long-term behaviour. And this is the work I put into a simple script that only I need to run. If this were going to be a production system, I'd have to take it to a whole other level, and I would expect engineering teams I work with to do the same.\n\nI'm certainly not done, and the scripts I use get continuous refinement and are adapted as I learn more and need more. Here are some ideas for improvements:\n\nHere’s what I’m noodling on next:\n\n- **Separate concerns in PowerShell** — I already have reusable modules, but I can sharpen this by splitting orchestration logic and reusable functions into clean, distinct scripts or modules.\n- **Use structured exceptions** — Plain error logs only get me so far; I want to move to proper PowerShell error records or thrown exceptions so failures are surfaced intentionally, not passively.\n- **Add FastAPI health and version endpoints** — Lightweight /health and /version routes will let me run fast checks and diagnostics without poking deep into the server.\n- **Introduce concurrency handling** — Adding PowerShell locking or a mutex will protect against race conditions if multiple scripts try to touch the server at once.\n- **Dockerize the Python token server** — Packaging the server into a Docker container will give me environment isolation and smoother deployment, especially when moving between local and cloud setups.\n- **Implement structured logging** — I want to replace Write-Host or Write-InfoLog with structured log outputs (like JSON or key-value pairs) so logs are machine-readable and easier to pipeline.\n- **Write automated tests** — Pester for PowerShell unit tests and pytest with httpx for FastAPI endpoint testing will give me confidence this system holds up, even as I evolve and extend it.\n\nBut for now, I'm happy that it's executing and reasonably resilient. Next time I run it I might not feel the same and make more changes.\n\n# Final Takeaway\n\nBuilding resilient systems is not about making them work once. It is about making sure they keep working when the environment turns hostile. This mindset aligns directly with the DevOps ethos: accountability, continuous improvement, and designing systems that deliver reliable value no matter the noise or disruption. This Token Server journey was a microcosm of that challenge, and the lessons apply far beyond token counting.\n\n- Design for failure.\n- Build in observability.\n- Create fallback paths.\n- Prioritise flow, not brute-force restarts.\n",
    "FilePath": "C:\\Users\\MartinHinshelwoodNKD\\source\\repos\\NKDAgility.com\\site\\content\\resources\\engineering-notes\\2025-05-08-resilient-token-server\\index.md",
    "FolderPath": "C:\\Users\\MartinHinshelwoodNKD\\source\\repos\\NKDAgility.com\\site\\content\\resources\\engineering-notes\\2025-05-08-resilient-token-server",
    "ReferencePath": "resources/engineering-notes/2025-05-08-resilient-token-server"
  }
]
