post:
  title: Solution - SEO permanent redirects for old URL’s?
  link: https://nkdagility.com/blog/solution-seo-permanent-redirects-for-old-urls/
  pubDate: Mon, 04 Jan 2010 02:34:55 +0000
  creator: MrHinsh
  guid:
    _: >-
      http://geekswithblogs.net/hinshelm/archive/2010/01/04/do-you-know-how-to-maintain-your-google-ranking-while.aspx
    $:
      isPermaLink: 'false'
  description: ''
  encoded:
  - "<p>From time to time, your website structure may change. When this happens, you do not want to have to start from scratch with your Google rankings, so you need to map all of your Old URLs to new ones.</p>\n<p>This may seem like a trivial thing, but it is essential to keep your current rankings, that you worked hard for, intact.</p>\n<p>In our scenario the old site used a query string with the product ID in it, and the new site uses nice friendly names.</p>\n<p>Old: <a href=\"http://northwind.com/Product/ProductInfo.aspx?id=3456\">http://northwind.com/Product/ProductInfo.aspx?id=3456</a></p>\n<p>New: <a href=\"http://northwind.com/CoolLightsaberWithRealAction.aspx\">http://northwind.com/CoolLightsaberWithRealAction.aspx</a></p>\n<p><font color=\"#ff0000\">Updated #1 January 5th, 2010: </font><font color=\"#000000\">- As suggested by </font><a rel=\"nofollow\" target=\"_blank\" href=\"http://sharepoint.ssw.com.au/AboutUs/Employees/Pages/Adam.aspx\">Adam Cogan</a>, I changed:</p>\n<ul>\n    <li>Change Figures to SSW standard with “Good example, ….”, “OK example, ….” And “Bad example, ….“</li>\n    <li>Prefix main headings with “Option #x” to make them stand out</li>\n    <li>Prefix process steps with “Step #x” to differentiate them.</li>\n    <li>Remove tiny URL’s so the reader knows where they are going</li>\n    <li>Spell check (i.e. run through Word)</li>\n    <li>Link to rules for better regex</li>\n    <li>Change “outtakes” to “TODO:”’s</li>\n    <li>End on an impact line (“In conclusion I …..”)</li>\n    <li>Change Title to\_ “Solution - SEO permanent redirects for old URL’s?”</li>\n</ul>\n<p><font color=\"#ff0000\">Updated #2 January 6th, 2010: –</font><font color=\"#000000\">As suggested by </font><a rel=\"nofollow\" target=\"_blank\" href=\"http://sharepoint.ssw.com.au/AboutUs/Employees/Pages/John.aspx\">John Liu</a>, I changed the SQL call to be completely wrapped in a “try catch” statement and to close the connection in the “Finally” area. Dam, I thought no one at SSW could read VB.</p>\n<p><font color=\"#ff0000\">Updated #3 January 7th, 2010: </font><font color=\"#000000\">- As suggested by </font><a rel=\"nofollow\" target=\"_blank\" href=\"http://sharepoint.ssw.com.au/AboutUs/Employees/Pages/Peter.aspx\">Peter Gfader</a>, I changed the source to use a parameterised SQL statement instead of a Stored Procedure. He pointed out that “<a title=\"Stored procedures are bad, m'kay?\" rel=\"nofollow\" target=\"_blank\" href=\"http://weblogs.asp.net/fbouma/archive/2003/11/18/38178.aspx\">Stored procedures are bad, m'kay?</a>”</p>\n<p><font color=\"#ff0000\">Updated #4 January 8th, 2010:</font> – Updated to reflect latest code changes to increase flexibility of the rule.</p>\n<hr />\n<h2>Option #1 - You can do it in product.aspx</h2>\n<pre>\n// …\n// Lookup database here and find the friendly name for the product with the ID 3456\n// …\nResponse.Status = \"301 Moved Permanently\"\nResponse.StatusCode = 301;   \nResponse.AddHeader(\"Location\",\"/CoolLightsaberWithRealAction.aspx\");\nResponse.End();</pre>\n<p>Figure: Bad example, Write it right into the old page. <br />\n<br />\n<br />\n\_</p>\n<p>Why is this not a good approach?</p>\n<ul>\n    <li>The old page may not exist, you may be building a whole new version of the site</li>\n    <li>It is slow. You have to wait for the page to load, which probably means your master page, and all the code which goes with that.</li>\n    <li>It leaves old pages dotted about your site that you do not really want.</li>\n</ul>\n<h2>Option #2 - You can do it in the global.asax</h2>\n<pre>\nprotected void Application_BeginRequest(object sender, EventArgs e)\n{\n    \n    if (Request.FilePath.Contains(\"/product.aspx?id=\") \n    {\n        // ...\n        // Lookup the ID in the database to get the new friendly name\n        // ...\n        Response.Status=\"301 Moved Permanently\"\n        Response.StatusCode=301;\n        Response.Redirect (\"/CoolLightsaberWithRealAction.aspx\", true);\n    }\n}</pre>\n<p>Figure: Bad example, ASP.NET 2.0 solution in the global.asax file for redirects <br />\n<br />\n<br />\n\_</p>\n<pre>\nprotected void Application_BeginRequest(object sender, EventArgs e)\n{\n    \n    if (Request.FilePath.Contains(\"/product.aspx?id=\") \n    {\n        // ...\n        // Lookup the ID in the database to get the new friendly name\n        // ...\n        Response.RedirectPermanent(\"/CoolLightsaberWithRealAction.aspx\", true);\n    }\n}</pre>\n<p>Figure: Bad example, ASP.NET 4.0 solution in the global.asax file for redirects, less code. <br />\n<br />\n<br />\n\_</p>\n<p>Using the global.asax has its draw backs.</p>\n<ul>\n    <li>To change it you must make a code change to your site and re-deploy</li>\n    <li>If you have multiple redirects it is going to get ugly fast.</li>\n</ul>\n<h2>Option #3 - You can do it with the IIS7 URL Rewrite Module</h2>\n<p>Using the IIS7 URL Rewrite Module which can be installed using the <a href=\"http://www.microsoft.com/web/downloads/platform.aspx\">Microsoft Web Platform Installer</a> is the best option, but unfortunately it does <a rel=\"nofollow\" target=\"_blank\" href=\"http://blog.hinshelwood.com/archive/2009/12/28/do-you-know-how-to-permanently-redirect-old-incoming-urlrsquos.aspx\">not currently support</a> looking up a database.</p>\n<p>If you have identifiable patterns in the rewrites that you want to perform then this is fantastic. So if you have all of the information that you need in the URL to do the rewrite, then you can stop reading and go an install it.</p>\n<p>With the IIS7 URL Rewrite Module you can</p>\n<ul>\n    <li>Rewrite and redirect URLs</li>\n    <li>Handles requests before ASP.NET is aware of (good performance)</li>\n    <li>Solves both problems: redirecting broken pages and creating nice URLs</li>\n    <li><b>Various rule actions</b>. Instead of rewriting a URL, a rule may perform other actions, such as issue an HTTP redirect, abort the request, or send a custom status code to HTTP client.</li>\n    <li>Nice graphical rule editor</li>\n    <li>Regex pattern matching for requests and rewrites</li>\n    <li>URL rewrite module v2 adds support for outbound response rewriting</li>\n    <li>Fix up the content of any HTTP response by using regular expression pattern matching (e.g. modify links in outgoing response)</li>\n</ul>\n<p>As it turns out, we found out yesterday that the next version of the IIS7 URL Rewriting Module IS going to support loading from a database! Wither that is just loading the rules, or you can load some of the data you need has yet to be seen. But as we can’t get even a beta for a couple of weeks, and our release date is in that region we could not wait.</p>\n<h2>Option #4 - You can do it with UrlRewritingNet.UrlRewriter</h2>\n<p>Using the <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.urlrewriting.net\">UrlRewritingNet.UrlRewriter</a> component you can do pretty much everything that the IIS7 Rewrite Module does, but it does not have a nice UI to interact with. The best part of UrlRewritingNet.UrlRewriter is that its rules engine is extensible, so we can add a new rule type to load from a database.</p>\n<p>The first thing you do with any new toolkit is read the documentation, or at least have it open and pretend to read it while you tinker.</p>\n<h3>Step #1 - Add UrlRewritingNet.UrlRewriter to our site</h3>\n<p>To add UrlRewritingNet.UrlRewriter to our site you need to add UrlRewritingNet.UrlRewriter.dll (you can download this from their site) to the Bin folder and make a couple of modifications to the web.config. I have opted to add the UrlRewritingNet.UrlRewriter section of the config to a separate file as this makes it more maintainable.</p>\n<pre>\n&lt;?xml version=\"1.0\"?&gt;\n&lt;urlrewritingnet xmlns=\"http://www.urlrewriting.net/schemas/config/2006/07\"&gt;\n  &lt;providers&gt;\n    &lt;!-- providers go here --&gt;\n  &lt;/providers&gt;\n  &lt;rewrites&gt;\n      &lt;!-- rules go here --&gt;\n  &lt;/rewrites&gt;\n&lt;/urlrewritingnet&gt;</pre>\n<p>Figure: Boilerplate URLRewriting config. <br />\n<br />\n<br />\n\_</p>\n<p>Create a new blank file called \"urlrewriting.config\" and insert the code above. As you can see you can add numerous providers and rules. Lookup the documentation for the built in rules model that uses the same method we will be using to capture URL's, but has a regular expression based replace implementation that lets you reform any URL into any other URL, provided all the values you need are either static, or included in the incoming URL.</p>\n<pre>\n&lt;configSections&gt;\n  ...\n  &lt;section name=\"urlrewritingnet\"\n      restartOnExternalChanges=\"true\"\n      requirePermission=\"false\"\n      type=\"UrlRewritingNet.Configuration.UrlRewriteSection, UrlRewritingNet.UrlRewriter\"       /&gt;\n&lt;/configSections&gt;  </pre>\n<p>Figure: ASP.NET Section definition for URLRewriting. <br />\n<br />\n<br />\n\_</p>\n<p>In your \"web.config\" add this section.</p>\n<pre>\n&lt;urlrewritingnet configSource=\"UrlRewrite.config\" /&gt;</pre>\n<p>Figure: You can use an external file or inline. <br />\n<br />\n<br />\n\_</p>\n<p>After the sections definition, but NOT inside any other section, add the section implementation, but use the \"configSource\" tag to map it to the \"urlrewriting.config\" file you created previously. You could also just add the contents of \"urlrewriting.config\" under \"urlrewritingnet\" element and remove the need for the additional file, but I think this is neater.</p>\n<pre>\n&lt;system.web&gt;\n  &lt;httpModules&gt;\n    &lt;add name=\"UrlRewriteModule\"\n      type=\"UrlRewritingNet.Web.UrlRewriteModule, UrlRewritingNet.UrlRewriter\" /&gt;\n  &lt;/httpModules&gt;\n&lt;/system.web&gt;</pre>\n<p>Figure: HttpModules make it all work in IIS6. <br />\n<br />\n<br />\n\_</p>\n<p>We need IIS to know that it needs to do some processing, but there are some key differences between IIS6 and IIS7, to make sure that both load your rewrite correctly, especially if you still have developers on Windows XP, you will need to add both of them. Add this one to the \"HttpModules\" element, before any other rewriting modules, it tells IIS6 that it needs to load the module.</p>\n<pre>\n&lt;system.webServer&gt;\n  &lt;modules&gt;\n    &lt;add name=\"UrlRewriteModule\"\n      type=\"UrlRewritingNet.Web.UrlRewriteModule, UrlRewritingNet.UrlRewriter\" /&gt;\n  &lt;/modules&gt;\n&lt;/system.webServer&gt;</pre>\n<p>Figure: Modules make it all work in IIS7. <br />\n\_</p>\n<p>II7 does things a little differently, so add the above to the \"modules\" element of \"system.webServer\". This does exactly the same thing, but slots it into the IIS7 pipeline.</p>\n<p>You should now be able to add rules as specified in the documentation and have them run successfully, provided you have your regular expression\_ is correct :), but for this process we need to write our custom rule.</p>\n<h3>Step #2 - Creating a blank custom rule</h3>\n<p>For some reason I have not yet fathomed, you need to create a “Provider” as well. It just has boilerplate code, but I would assume that there are circumstances when it would be useful to have some code in there.</p>\n<pre>\nImports UrlRewritingNet.Configuration.Provider\n\nPublic Class SqlUrlRewritingProvider\n    Inherits UrlRewritingProvider\n\n    Public Overrides Function CreateRewriteRule() As UrlRewritingNet.Web.RewriteRule\n        Return New SqlRewriteRule\n    End Function\n\nEnd Class</pre>\n<p>Figure: Simple code for the provider. <br />\n\_</p>\n<p>All you need to do in the Provider is override the “CreateRewriteRule” and pass back an instance of your custom rule.</p>\n<pre>\nImports UrlRewritingNet.Web\nImports UrlRewritingNet.Configuration\nImports System.Configuration\n\nPublic Class SqlRewriteRule\n    Inherits RewriteRule\n\n    Public Overrides Sub Initialize(ByVal rewriteSettings As RewriteSettings)\n        MyBase.Initialize(rewriteSettings)\n    End Sub\n\n    Public Overrides Function IsRewrite(ByVal requestUrl As String) As Boolean\n        Return false\n    End Function\n\n    Public Overrides Function RewriteUrl(ByVal url As String) As String\n        Return url\n    End Function\n\nEnd Class</pre>\n<p>Figure: Boilerplate Rule. <br />\n<br />\n<br />\n\_</p>\n<p>This is a skeleton of a new rule. It does nothing now, and in fact will not run as long as the “IsRewrite” function returns false.</p>\n<p>The “Initialize” method passes any setting that are set on the rule entry in the config file. As we want to create a dynamic and reusable rule, we will be using a lot of settings. The settings are written as Attributes in the XML, but are in effect name value pairs.</p>\n<p>The “IsRewrite” will determine wither we want to run the logic behind the rule. I would not advice any performance intensive calls here (like calling the database), so you should find a quick and easy way of determining if we want to proceed to rewrite the URL. The best way of doing this will be via a regular expression.</p>\n<p>“RewiteUrl” provides the actual logic to do the rewrite. We will be calling the database here so this is more intensive work.</p>\n<h3>Step #3 - Capture the URL you want to rewrite</h3>\n<p>Let’s first consider the capturing of the URL so we can do the IsRewrite. To provide our regular expression we will need to options, the first being our pattern, the second being the Regular expression options. We add the options so we can have both Case sensitive and insensitive settings. The standard field name for regular expressions that match is “VirtualUrl” we will just call the other “RegexOptions”.</p>\n<pre>\nImports UrlRewritingNet.Web\nImports UrlRewritingNet.Configuration\nImports System.Data.SqlClient\nImports System.Text.RegularExpressions\nImports System.Configuration\n\nPublic Class SqlRewriteRule\n    Inherits RewriteRule\n\n    Private m_regexOptions As Text.RegularExpressions.RegexOptions\n    Private m_virtualUrl As String = String.Empty\n\n    Public Overrides Sub Initialize(ByVal rewriteSettings As RewriteSettings)\n        Me.m_regexOptions = rewriteSettings.GetEnumAttribute(Of RegexOptions)(\"regexOptions\", RegexOptions.None)\n        Me.m_virtualUrl = rewriteSettings.GetAttribute(\"virtualUrl\", \"\")\n        MyBase.Initialize(rewriteSettings)\n    End Sub\n\n    Public Overrides Function IsRewrite(ByVal requestUrl As String) As Boolean\n        Return true\n    End Function\n\n    Public Overrides Function RewriteUrl(ByVal url As String) As String\n        Return url\n    End Function\n\n   \nEnd Class</pre>\n<p>Figure: Retrieving values from the config is easy. <br />\n<br />\n<br />\n\_</p>\n<p>In order to capture these values we just add two fields to our class, and parse out the data from “rewriteSettings” for these two fields in the Initialize method.</p>\n<pre>\nImports UrlRewritingNet.Web\nImports UrlRewritingNet.Configuration\nImports System.Text.RegularExpressions\nImports System.Configuration\n\nPublic Class ProductKeyRewriteRule\n    Inherits RewriteRule\n\n    Private m_regex As Text.RegularExpressions.Regex\n    Private m_regexOptions As Text.RegularExpressions.RegexOptions\n    Private m_virtualUrl As String = String.Empty\n\n    ' Methods\n    Private Sub CreateRegEx()\n        Dim helper As New UrlHelper\n        If MyBase.IgnoreCase Then\n            Me.m_regex = New Regex(helper.HandleRootOperator(Me.m_virtualUrl), ((RegexOptions.Compiled Or RegexOptions.IgnoreCase) Or Me.m_regexOptions))\n        Else\n            Me.m_regex = New Regex(helper.HandleRootOperator(Me.m_virtualUrl), (RegexOptions.Compiled Or Me.m_regexOptions))\n        End If\n    End Sub\n\n    Public Overrides Sub Initialize(ByVal rewriteSettings As RewriteSettings)\n        Me.m_regexOptions = rewriteSettings.GetEnumAttribute(Of RegexOptions)(\"regexOptions\", RegexOptions.None)\n        Me.m_virtualUrl = rewriteSettings.GetAttribute(\"virtualUrl\", \"\")\n        CreateRegEx\n        MyBase.Initialize(rewriteSettings)\n    End Sub\n\n    Public Overrides Function IsRewrite(ByVal requestUrl As String) As Boolean\n        Return Me.m_regex.IsMatch(requestUrl)\n    End Function\n\n    Public Overrides Function RewriteUrl(ByVal url As String) As String\n        Return url\n    End Function\n\n   \nEnd Class</pre>\n<p>Figure: Creating an instance of a regular expression and using that is always faster than creating one each time. <br />\n<br />\n<br />\n\_</p>\n<p>We now have all of the information we need to create a regular expression and call \"IsMatch\" in the \"IsRewrite\" method. Therefore, we add another field for the regular expression and add a “CreateRegEx” method to create our regular expression using the built in “Ignorecase” option as well as our “RegexOptions” value. This creates a single compiled copy of our regular expression so it will operate as quickly as possible. Remember that this code will now be called for EVERY incoming URL request.</p>\n<h3>Step #4 - Rewrite the URL with data from the database</h3>\n<p>Now that we have captured the URL, we need to rewrite it. in order to do this we will need some extra fields, and this is were things get a little complicated because we want to be generic. We will need:</p>\n<ul>\n    <li>a connection string so we know where to load the data from</li>\n    <li>a SQL Statement</li>\n    <li>some input parameters for our SQL</li>\n    <li>some output data</li>\n    <li>a destination URL to inject our output into</li>\n    <li>a place to redirect users to if all else fails</li>\n</ul>\n<p>The connection string is easy, or is it.</p>\n<pre>\n' Test for connectionString and throw exception if not available\nm_ConnectionString = rewriteSettings.GetAttribute(\"connectionString\", String.Empty)\nIf m_ConnectionString = String.Empty Then\n    Throw New NotSupportedException(String.Format(\"You must specify a connectionString attribute for the DataRewriteRule {0}\", rewriteSettings.Name))\nEnd If\n' Check to see if this is a named connection string\nDim NamedConnectionString As ConnectionStringSettings = ConfigurationManager.ConnectionStrings(m_ConnectionString)\nIf Not NamedConnectionString Is Nothing Then\n    m_ConnectionString = NamedConnectionString.ConnectionString\nEnd If</pre>\n<p>Figure: Make sure that you check wither values are correct. <br />\n<br />\n<br />\n\_</p>\n<p>There are two ways for a connection string to be stored in ASP.NET, inline and shared. We don’t want to be fixed to a specific type, so we need to assume shared and if we can’t find a shared string, assume that the string provided in the connection string and not a key for the shared string.</p>\n<p>The stored procedure is just a string, but the input parameters, now that is a quandary. Where can we get them from and now can we configure them. Although it would probably be best if we could have sub elements to the rule definition in the “web.config” we can’t, so all we have is a set of name value pairs.</p>\n<pre>\n^.*/Product/ProductInfo.aspx?id=(?'ProductId'd+)</pre>\n<p>Figure: Follow the rule: <a rel=\"nofollow\" target=\"_blank\" href=\"http://www.ssw.com.au/ssw/standards/Rules/RulesToBetterRegularExpressions.aspx#testregex\">Do you test your regular expressions?</a> <br />\n<br />\n<br />\n<br />\n\_</p>\n<p>The solution I went for was to use Named groups in the regular expression. The only input parameter with this expression would be “@ProductId” and should be populated by the data in the capture group for the regular expression.</p>\n<pre>\n' Get all the named groups from the regular expression and use them as the stored procedure parameters.\nDim groupNames = From groupName In m_regex.GetGroupNames Where Not groupName = String.Empty And Not IsNumeric(groupName)\n' Iterate through the named groups\nFor Each groupName As String In groupNames\n   ' Add the name and value to the saved replacements\n   UrlReplacements.Add(groupName, match.Groups(groupName).ToString)\n   ' Add the name and value as input prameters to the stored procedure\n   cmd.Parameters.AddWithValue(\"@\" &amp; groupName, match.Groups(groupName).ToString)\nNext</pre>\n<p>Figure: Retrieving the named groups is easier than you think, but remember that it also contains the unnamed groups as a number. <br />\n<br />\n<br />\n\_</p>\n<p>So for each of the group names found in the regular expression I will be adding a SqlParameter to the SqlCommand object with the value that is returned. Again, a better solution would be to have meta data along with this that would identify the input parameters as well as data types and where to get them from, but alas it is not possible in this context.</p>\n<p>All this allows you to call a parameterised SQL statement and get some data back that you can use in the “RewriteUrl” method. I created a “GetUrlReplacements” method to encapsulate this logic.</p>\n<pre>\nPrivate Function GetUrlReplacements(ByVal match As Match) As Dictionary(Of String, String)\n    Dim UrlReplacements As New Dictionary(Of String, String)\n    Dim paramString As String = String.Empty\n    ' Call database\n    Using conn As New SqlConnection(m_ConnectionString)\n        Try\n            conn.Open()\n            Dim cmd As New SqlCommand(m_parameterisedSql, conn)\n            cmd.CommandType = CommandType.Text\n            ' Get all the named groups from the regular expression and use them as the stored procedure parameters.\n            Dim groupNames = From groupName In m_regex.GetGroupNames Where Not groupName = String.Empty And Not IsNumeric(groupName)\n            ' Iterate through the named groups\n            For Each groupName As String In groupNames\n                ' Add the name and value as input prameters to the stored procedure\n                cmd.Parameters.AddWithValue(\"@\" &amp; groupName, match.Groups(groupName).ToString)\n                paramString = paramString &amp; \"[@\" &amp; groupName &amp; \"=\" &amp; match.Groups(groupName).ToString &amp; \"]\"\n                If UrlReplacements.ContainsKey(groupName) Then\n                    UrlReplacements.Add(groupName, match.Groups(groupName).ToString)\n                Else\n                    UrlReplacements(groupName) = match.Groups(groupName).ToString\n                End If\n            Next\n            ' Defigne the data capture method\n            Dim sqlReader As SqlClient.SqlDataReader\n            ' Execute the SQL\n            sqlReader = cmd.ExecuteReader()\n            If sqlReader.HasRows Then\n                Dim isDone As Boolean = False\n                Do While sqlReader.Read()\n                    If isDone Then\n                        ' If more than one record is returned, exit and record\n                        My.Application.Log.WriteEntry(String.Format(\"Too many results from execution of '{0}' using parameters '{1}' on the connection '{2}'. Make sure your query only returns a single record.\", m_parameterisedSql, paramString, m_ConnectionString), TraceEventType.Error, 19786)\n                        Exit Do\n                    End If\n                    ' Add a sql output parameter for each outputParam (note: Must be NVarChar(255))\n                    For i As Integer = 0 To sqlReader.FieldCount - 1\n                        If UrlReplacements.ContainsKey(sqlReader.GetName(i)) Then\n                            UrlReplacements.Add(sqlReader.GetName(i), sqlReader.GetValue(i).ToString)\n                        Else\n                            UrlReplacements(sqlReader.GetName(i)) = sqlReader.GetValue(i).ToString\n                        End If\n                    Next\n                    isDone = True\n                Loop\n                sqlReader.Close()\n            Else\n                My.Application.Log.WriteEntry(String.Format(\"No results from execution of '{0}' using parameters '{1}' on the connection '{2}'\", m_parameterisedSql, paramString, m_ConnectionString), TraceEventType.Error, 19784)\n                UrlReplacements.Clear()\n                UrlReplacements.Add(\"results\", \"None\")\n            End If\n        Catch ex As System.Data.SqlClient.SqlException\n            My.Application.Log.WriteException(ex, TraceEventType.Error, String.Format(\"Unable to execute '{0}' using parameters '{1}' on the connection '{2}'\", m_parameterisedSql, paramString, m_ConnectionString), 19783)\n            UrlReplacements.Clear()\n            UrlReplacements.Add(\"ex\", \"SqlException\")\n        Catch ex As Exception\n            My.Application.Log.WriteException(ex, TraceEventType.Error, String.Format(\"Unable to connect using the connection '{0}'\", m_ConnectionString), 19782)\n            UrlReplacements.Clear()\n            UrlReplacements.Add(\"ex\", ex.GetType.ToString)\n        End Try\n    End Using\n    Return UrlReplacements\nEnd Function</pre>\n<p>Figure: Always encapsulate your more complicated logic, especially database calls. <br />\n<br />\n<br />\n\_</p>\n<p>The SQL is called and the first, and only the first, returned record is parsed into a name value collection allowing for multiple values to be returned.</p>\n<p>Now that we have the relevant data, we can rewrite the URL.</p>\n<pre>\nPublic Overrides Function RewriteUrl(ByVal url As String) As String\n    ' Get the url replacement values\n    Dim UrlReplacements As Dictionary(Of String, String) = GetUrlReplacements(Me.m_regex.Match(url))\n    ' Take a copy of the target url\n    Dim newUrl As String = m_destinationUrl\n    ' Replace any valid values with the new value\n    For Each key As String In UrlReplacements.Keys\n        newUrl = newUrl.Replace(\"{\" &amp; key &amp; \"}\", UrlReplacements(key))\n    Next\n    ' Test to see is any failed by looking for any left over '{'\n    If newUrl.Contains(\"{\") Then\n        ' If there are left over bits, then only do a Tempory redirect to the failed URL\n        Me.RedirectMode = RedirectModeOption.Temporary\n        My.Application.Log.WriteEntry(String.Format(\"Unable to locate a product url replacement for {0}\", url), TraceEventType.Error, 19781)\n        Return (String.Format(m_RedirectToOnFail, Me.Name, \"NotFound\", UrlReplacementsToQueryString(UrlReplacements)))\n    End If\n    ' Sucess, so do a perminant redirect to the new url.\n    My.Application.Log.WriteEntry(String.Format(\"Redirecting {0} to {1}\", url, newUrl), TraceEventType.Information, 19780)\n    Me.RedirectMode = RedirectModeOption.Permanent\n    Return newUrl.Replace(\"^\", \"\")\nEnd Function</pre>\n<p>Figure: Make sure that there is a backup plan for your rewrites. <br />\n<br />\n<br />\n\_</p>\n<p>As you can see all we do once we have the replacement values is replace the keys from the “DestinationUrl” value with the new values. One additional test is done to check that we have not miss-configured and left some values out, so check to see if there are any “{“ left and redirect to the\_ “redirectOnFailed” location if we did. This will be caught if either we did not get any data back, or we just messed up the configuration.</p>\n<p>Lets setup the rule in the config.</p>\n<pre>\n&lt;?xml version=\"1.0\"?&gt;\n&lt;urlrewritingnet xmlns=\"http://www.urlrewriting.net/schemas/config/2006/07\"&gt;\n  &lt;providers&gt;\n    &lt;add name=\"SqlUrlRewritingProvider\" type=\"SSW.UrlRewriting.SqlUrlRewritingProvider, SSW.UrlRewriting\"/&gt;\n  &lt;/providers&gt;\n  &lt;rewrites&gt;\n    &lt;add name=\"Rule2\"\n        provider=\"SqlUrlRewritingProvider\"\n        connectionString=\"MyConnectionString\"\n        virtualUrl=\"^.*/Product/ProductInfo.aspx?id=(?'ProductId'd+)\"\n        parameterisedSql=\"SELECT dbo.CatalogEntry.Code as ProductId, dbo.CatalogItemSeo.Uri as ProductKey FROM\_ dbo.CatalogEntry INNER JOIN dbo.CatalogItemSeo ON dbo.CatalogEntry.CatalogEntryId = dbo.CatalogItemSeo.CatalogEntryId WHERE Code = @ProductId\"\n        DestinationUrl=\"^~/{ProductKey}\"\n        rewriteUrlParameter=\"IncludeQueryStringForRewrite\"\n        redirectToOnFail=\"~/default.aspx?rewrite=productNotFound\"\n        redirectMode=\"Permanent\"\n        redirect=\"Application\"\n        rewrite=\"Application\"\n        ignoreCase=\"true\" /&gt;\n  &lt;/rewrites&gt;\n&lt;/urlrewritingnet&gt;</pre>\n<p>Figure: You can configure as many rules as you like. <br />\n<br />\n<br />\n\_</p>\n<p>The final config entry for the rule looks complicated, but it should all make sense to you now that all the logic has been explained. There are some additional propertied here that are part of the Rewriting engine, but you will find them all in the documentation.</p>\n<p>In conclusion, hopefully the IIS7 module will support a more elegant solution in its next iteration, and you can always just hard code an HttpModule. This however is the beginnings of a more dynamic solution that can be used over and over again, even in the one site.</p>\n<p>For those of you that can’t be bothered to piece this all together, here is the full rule source, but Don’t forget to skip to the bottom for the TODO.</p>\n<pre>\nImports UrlRewritingNet.Web\nImports UrlRewritingNet.Configuration\nImports System.Data.SqlClient\nImports System.Text.RegularExpressions\nImports System.Configuration\n\nPublic Class SqlRewriteRule\n    Inherits RewriteRule\n\n    Private m_ConnectionString As String\n    Private m_parameterisedSql As String\n    Private m_destinationUrl As String = String.Empty\n    Private m_regex As Text.RegularExpressions.Regex\n    Private m_regexOptions As Text.RegularExpressions.RegexOptions\n    Private m_virtualUrl As String = String.Empty\n    Private m_RedirectToOnFail As String\n\n    ' Methods\n    Private Sub CreateRegEx()\n        Dim helper As New UrlHelper\n        If MyBase.IgnoreCase Then\n            Me.m_regex = New Regex(helper.HandleRootOperator(Me.m_virtualUrl), ((RegexOptions.Compiled Or RegexOptions.IgnoreCase) Or Me.m_regexOptions))\n        Else\n            Me.m_regex = New Regex(helper.HandleRootOperator(Me.m_virtualUrl), (RegexOptions.Compiled Or Me.m_regexOptions))\n        End If\n    End Sub\n\n    Public Overrides Sub Initialize(ByVal rewriteSettings As RewriteSettings)\n        Me.m_regexOptions = rewriteSettings.GetEnumAttribute(Of RegexOptions)(\"regexOptions\", RegexOptions.None)\n        Me.m_virtualUrl = rewriteSettings.GetAttribute(\"virtualUrl\", \"\")\n        Me.m_destinationUrl = rewriteSettings.GetAttribute(\"destinationUrl\", \"\")\n        Me.CreateRegEx()\n        ' Test for connectionString and throw exception if not available\n        m_ConnectionString = rewriteSettings.GetAttribute(\"connectionString\", String.Empty)\n        If m_ConnectionString = String.Empty Then\n            Throw New NotSupportedException(String.Format(\"You must specify a connectionString attribute for the DataRewriteRule {0}\", rewriteSettings.Name))\n        End If\n        ' Check to see if this is a named connection string\n        Dim NamedConnectionString As ConnectionStringSettings = ConfigurationManager.ConnectionStrings(m_ConnectionString)\n        If Not NamedConnectionString Is Nothing Then\n            m_ConnectionString = NamedConnectionString.ConnectionString\n        End If\n        ' Test for storedProcedure and throw exception if not available\n        m_parameterisedSql = rewriteSettings.GetAttribute(\"parameterisedSql\", String.Empty)\n        If m_parameterisedSql = String.Empty Then\n            Throw New NotSupportedException(String.Format(\"You must specify a parameterisedSql attribute for the DataRewriteRule {0}\", rewriteSettings.Name))\n        End If\n\n        ' Test for redirectToOnFail and throw exception if not available\n        m_RedirectToOnFail = rewriteSettings.GetAttribute(\"redirectToOnFail\", String.Empty)\n        If m_RedirectToOnFail = String.Empty Then\n            Throw New NotSupportedException(String.Format(\"You must specify a redirectToOnFail attribute for the DataRewriteRule {0}\", rewriteSettings.Name))\n        End If\n        MyBase.Initialize(rewriteSettings)\n    End Sub\n\n    Public Overrides Function IsRewrite(ByVal requestUrl As String) As Boolean\n        Return Me.m_regex.IsMatch(requestUrl)\n    End Function\n\n    Public Overrides Function RewriteUrl(ByVal url As String) As String\n        ' Get the url replacement values\n        Dim UrlReplacements As Dictionary(Of String, String) = GetUrlReplacements(Me.m_regex.Match(url))\n        ' Take a copy of the target url\n        Dim newUrl As String = m_destinationUrl\n        ' Replace any valid values with the new value\n        For Each key As String In UrlReplacements.Keys\n            newUrl = newUrl.Replace(\"{\" &amp; key &amp; \"}\", UrlReplacements(key))\n        Next\n        ' Test to see is any failed by looking for any left over '{'\n        If newUrl.Contains(\"{\") Then\n            ' If there are left over bits, then only do a Tempory redirect to the failed URL\n            Me.RedirectMode = RedirectModeOption.Temporary\n            My.Application.Log.WriteEntry(String.Format(\"Unable to locate a product url replacement for {0}\", url), TraceEventType.Error, 19781)\n            Return (String.Format(m_RedirectToOnFail, Me.Name, \"NotFound\", UrlReplacementsToQueryString(UrlReplacements)))\n        End If\n        ' Sucess, so do a perminant redirect to the new url.\n        My.Application.Log.WriteEntry(String.Format(\"Redirecting {0} to {1}\", url, newUrl), TraceEventType.Information, 19780)\n        Me.RedirectMode = RedirectModeOption.Permanent\n        Return newUrl.Replace(\"^\", \"\")\n    End Function\n\n    Private Function GetUrlReplacements(ByVal match As Match) As Dictionary(Of String, String)\n        Dim UrlReplacements As New Dictionary(Of String, String)\n        Dim paramString As String = String.Empty\n        ' Call database\n        Using conn As New SqlConnection(m_ConnectionString)\n            Try\n                conn.Open()\n                Dim cmd As New SqlCommand(m_parameterisedSql, conn)\n                cmd.CommandType = CommandType.Text\n                ' Get all the named groups from the regular expression and use them as the stored procedure parameters.\n                Dim groupNames = From groupName In m_regex.GetGroupNames Where Not groupName = String.Empty And Not IsNumeric(groupName)\n                ' Iterate through the named groups\n                For Each groupName As String In groupNames\n                    ' Add the name and value as input prameters to the stored procedure\n                    cmd.Parameters.AddWithValue(\"@\" &amp; groupName, match.Groups(groupName).ToString)\n                    paramString = paramString &amp; \"[@\" &amp; groupName &amp; \"=\" &amp; match.Groups(groupName).ToString &amp; \"]\"\n                    If UrlReplacements.ContainsKey(groupName) Then\n                        UrlReplacements.Add(groupName, match.Groups(groupName).ToString)\n                    Else\n                        UrlReplacements(groupName) = match.Groups(groupName).ToString\n                    End If\n                Next\n                ' Defigne the data capture method\n                Dim sqlReader As SqlClient.SqlDataReader\n                ' Execute the SQL\n                sqlReader = cmd.ExecuteReader()\n                If sqlReader.HasRows Then\n                    Dim isDone As Boolean = False\n                    Do While sqlReader.Read()\n                        If isDone Then\n                            ' If more than one record is returned, exit and record\n                            My.Application.Log.WriteEntry(String.Format(\"Too many results from execution of '{0}' using parameters '{1}' on the connection '{2}'. Make sure your query only returns a single record.\", m_parameterisedSql, paramString, m_ConnectionString), TraceEventType.Error, 19786)\n                            Exit Do\n                        End If\n                        ' Add a sql output parameter for each outputParam (note: Must be NVarChar(255))\n                        For i As Integer = 0 To sqlReader.FieldCount - 1\n                            If UrlReplacements.ContainsKey(sqlReader.GetName(i)) Then\n                                UrlReplacements.Add(sqlReader.GetName(i), sqlReader.GetValue(i).ToString)\n                            Else\n                                UrlReplacements(sqlReader.GetName(i)) = sqlReader.GetValue(i).ToString\n                            End If\n                        Next\n                        isDone = True\n                    Loop\n                    sqlReader.Close()\n                Else\n                    My.Application.Log.WriteEntry(String.Format(\"No results from execution of '{0}' using parameters '{1}' on the connection '{2}'\", m_parameterisedSql, paramString, m_ConnectionString), TraceEventType.Error, 19784)\n                    UrlReplacements.Clear()\n                    UrlReplacements.Add(\"results\", \"None\")\n                End If\n            Catch ex As System.Data.SqlClient.SqlException\n                My.Application.Log.WriteException(ex, TraceEventType.Error, String.Format(\"Unable to execute '{0}' using parameters '{1}' on the connection '{2}'\", m_parameterisedSql, paramString, m_ConnectionString), 19783)\n                UrlReplacements.Clear()\n                UrlReplacements.Add(\"ex\", \"SqlException\")\n            Catch ex As Exception\n                My.Application.Log.WriteException(ex, TraceEventType.Error, String.Format(\"Unable to connect using the connection '{0}'\", m_ConnectionString), 19782)\n                UrlReplacements.Clear()\n                UrlReplacements.Add(\"ex\", ex.GetType.ToString)\n            End Try\n        End Using\n        Return UrlReplacements\n    End Function\n\n    Private Function UrlReplacementsToQueryString(ByVal dic As Dictionary(Of String, String)) As String\n        Dim quer As String = String.Empty\n        For Each dicEntry In dic\n            quer = String.Format(\"{0}&amp;{1}={2}\", quer, dicEntry.Key, dicEntry.Value)\n        Next\n        Return quer\n    End Function\n\nEnd Class</pre>\n<p>Figure: Full source listing for the rule. <br />\n<br />\n\_</p>\n<p>----------</p>\n<h2>TODO</h2>\n<p>What would I change and why…or things that I just did not have time to do.</p>\n<p>\_</p>\n<p>\_</p>\n<p>\_</p>\n<p></p><del>\n<h3>TODO: Add more configurable parameters</h3>\n<p>The lack of meta data will lead to limitations in the future and ultimately the duplication of code. The ideal solution would be something like the ASP.NET SqlDataSource configuration, with a nice UI.</p>\n<pre>\n&lt;asp:SqlDataSource ID=\"SqlDataSource1\" runat=\"server\" \n    CacheExpirationPolicy=\"Sliding\" \n    ConnectionString=\"MyConnectionString\" \n    EnableCaching=\"True\" \n    SelectCommand=\"ssw_proc_SeoProductIdToProductKey\" \n    SelectCommandType=\"StoredProcedure\"&gt;\n    &lt;SelectParameters&gt;\n        &lt;asp:RegexParameter DbType=\"StringFixedLength\" DefaultValue=\"0\" \n            Name=\"ProductId\" RegexGroupName=\"ProductId\" Size=\"100\" Type=\"String\" /&gt;\n        &lt;asp:Parameter DbType=\"StringFixedLength\" Direction=\"Output\" Name=\"ProductKey\" \n            Size=\"255\" Type=\"String\" /&gt;\n    &lt;/SelectParameters&gt;\n&lt;/asp:SqlDataSource&gt;</pre>\n<p>Figure: Good Example, code from the ASP.NET 2.0 SqlDataSource. <br />\n<br />\n\_</p>\n<p>You should be able to configure any set of input and output parameters.</p>\n</del><del>\n<h3><del>TODO: Retrieve a record and replace based on the columns</del></h3>\n<p>It may make more sense to return a single record and perform the replaces based on the columns that are returned. This may help to reduce complexity while increasing functionality.</p>\n</del>\n<h3>TODO: Add caching to improve performance</h3>\n<p>Caching is a difficult thing as it depends on the amount of data returned, but it can improve the speed.</p>\n<p>\_</p>\n<div class=\"wlWriterEditableSmartContent\" style=\"padding-bottom: 0px;margin: 0px;padding-left: 0px;padding-right: 0px;float: none;padding-top: 0px\">Technorati Tags: <a rel=\"tag\" href=\"http://technorati.com/tags/SSW\">SSW</a>\_<a rel=\"tag\" href=\"http://technorati.com/tags/.NET\">.NET</a>\_<a rel=\"tag\" href=\"http://technorati.com/tags/Software+Development\">Software Development</a>\_<a rel=\"tag\" href=\"http://technorati.com/tags/CodeProject\">CodeProject</a>\_<a rel=\"tag\" href=\"http://technorati.com/tags/SP+2010\">SP 2010</a>\_<a rel=\"tag\" href=\"http://technorati.com/tags/SharePoint\">SharePoint</a>\_</div>"
  - ''
  post_id: '73'
  post_date: '2010-01-04 02:34:55'
  post_date_gmt: '2010-01-04 02:34:55'
  post_modified: '2010-01-04 02:34:55'
  post_modified_gmt: '2010-01-04 02:34:55'
  comment_status: open
  ping_status: open
  post_name: solution-seo-permanent-redirects-for-old-urls
  status: publish
  post_parent: '0'
  menu_order: '0'
  post_type: post
  post_password: ''
  is_sticky: '0'
  category: {}
  postmeta:
  - meta_key: authorsure_include_css
    meta_value: ''
  - meta_key: dsq_thread_id
    meta_value: '311601724'
  - meta_key: _flattr_post_language
    meta_value: ''
  - meta_key: _flattr_post_category
    meta_value: ''
  - meta_key: _flattr_post_hidden
    meta_value: ''
  - meta_key: _flattr_btn_disabled
    meta_value: ''
  - meta_key: _thumbnail_id
    meta_value: '7077'
  - meta_key: authorsure_include_css
    meta_value: ''
  - meta_key: _views_template
    meta_value: '0'
  - meta_key: _wpbitly
    meta_value: http://nkdalm.net/1aBMZnV
  - meta_key: _jetpack_related_posts_cache
    meta_value: >-
      a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1465364968;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:74;}i:1;a:1:{s:2:"id";i:11317;}i:2;a:1:{s:2:"id";i:144;}}}}
  - meta_key: _wpghs_github_path
    meta_value: _posts/2010-01-04-solution-seo-permanent-redirects-for-old-urls.md
  - meta_key: _sha
    meta_value: ''
  - meta_key: _wpml_media_has_media
    meta_value: '1'
  - meta_key: _tribe_ticket_capacity
    meta_value: '0'
  - meta_key: _tribe_ticket_version
    meta_value: 4.12.1.2
  - meta_key: ekit_post_views_count
    meta_value: '655'
  comment:
  - comment_id: '705'
    comment_author: settlement negotiations
    comment_author_email: ''
    comment_author_url: ''
    comment_author_IP: ''
    comment_date: '2010-05-30 04:29:40'
    comment_date_gmt: '2010-05-30 04:29:40'
    comment_content: >-
      Wow. This blog is truly a gold mine. I have been wallowing on this for
      quite sometime and here I am reading about it! I will actually try these
      tips and let you know how they work out! Thanks again mate.<br /><br />
    comment_approved: '1'
    comment_type: comment
    comment_parent: '0'
    comment_user_id: '0'
    commentmeta:
    - meta_key: dsq_parent_post_id
      meta_value: ''
    - meta_key: dsq_post_id
      meta_value: '209969930'
  - comment_id: '706'
    comment_author: dating website uk
    comment_author_email: ''
    comment_author_url: ''
    comment_author_IP: ''
    comment_date: '2010-10-16 18:27:55'
    comment_date_gmt: '2010-10-16 18:27:55'
    comment_content: >-
      I bookmarked this blog a while ago because of the informative content and
      I am never being dissapointed. Continue the good work.<br />
    comment_approved: '1'
    comment_type: comment
    comment_parent: '0'
    comment_user_id: '0'
    commentmeta:
    - meta_key: dsq_parent_post_id
      meta_value: ''
    - meta_key: dsq_post_id
      meta_value: '209969931'
  - comment_id: '4364'
    comment_author: related resource site
    comment_author_email: ''
    comment_author_url: http://www.scoop.it/t/social-media-by-phil-belleville
    comment_author_IP: 117.174.62.253
    comment_date: '2014-09-04 09:44:31'
    comment_date_gmt: '2014-09-04 08:44:31'
    comment_content: |-
      <strong>related resource site</strong>

      see here for top quality information on recommended you read anywhere
    comment_approved: '1'
    comment_type: trackback
    comment_parent: '0'
    comment_user_id: '0'
    commentmeta:
    - meta_key: akismet_result
      meta_value: 'false'
    - meta_key: akismet_history
      meta_value: >-
        a:4:{s:4:"time";d:1409820271.512498;s:7:"message";s:28:"Akismet cleared
        this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}
    - meta_key: akismet_history
      meta_value: >-
        a:4:{s:4:"time";d:1409857690.959357;s:7:"message";s:46:"MrHinsh changed
        the comment status to
        approved";s:5:"event";s:15:"status-approved";s:4:"user";s:7:"MrHinsh";}
