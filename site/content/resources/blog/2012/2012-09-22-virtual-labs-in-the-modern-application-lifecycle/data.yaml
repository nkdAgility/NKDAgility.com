post:
  title: Virtual Labs in the modern application lifecycle
  link: >-
    https://nkdagility.com/blog/virtual-labs-in-the-modern-application-lifecycle/
  pubDate: Sat, 22 Sep 2012 05:22:14 +0000
  creator: MrHinsh
  guid:
    _: http://blog.hinshelwood.com/?p=8803
    $:
      isPermaLink: 'false'
  description: ''
  encoded:
  - >-
    <p class="lead">In the world of modern application development we have many
    more moving parts than we ever did before and it has become increasingly
    difficult for organisations to effectively simulate their environments with
    virtual labs.</p>

    <p>Add to that the demand from Development Teams to be able to have many
    times the environments that they ever had before and that they also want the
    ability to engage with any version of the software being supported. Both
    Operations Teams and Development Teams are already suffering under the yoke
    of complexity that modern applications demand and we are now bombarding them
    with an even greater immediacy of that need. As most organisations move
    towards delivering software to production at least every 30 days, with the
    increasing likelihood of continuous delivery both of these teams are ready
    to implode. While inevitable and required for survival, agility has a heavy
    price in change for your organisation, people, processes and tools.</p>

    <p>Are you ready to rise to the challenge?</p>

    <p><a href="http://blog.hinshelwood.com/files/2012/09/image33.png"><img
    style="background-image: none; padding-top: 0px; padding-left: 0px; display:
    inline; padding-right: 0px; border-width: 0px;" title=" Virtual Lab is part
    of the ALM Infrastructure that make it all happen"
    src="http://blog.hinshelwood.com/files/2012/09/image_thumb33.png" alt="
    Virtual Lab is part of the ALM Infrastructure that make it all happen"
    width="640" height="369" border="0" /></a><br /><strong>Figure: Virtual Lab
    is part of the ALM Infrastructure that make it all happen</strong></p>

    <p>The advent of automated testing and virtualisation has gone a long way to
    help teams circumvent some of the complexities that building modern
    interconnected applications has brought. Indeed the Visual Studio 2012
    platform has been designed to help these Development and Operational teams
    take back the team rooms and not just catch up, but get out ahead of the
    curve and deliver the value that the companies and consumers so desperately
    desire. Visual Studio 2012 Team Foundation Server has continued to improve
    and simplify the Development Teams needs by integrating with Hyper-V
    directly.&nbsp; However Hyper-V is but one of the many virtualisation
    platforms available on the market and there is ample room for partners to
    pick up the slack. Microsoft is putting its skills to work where it is
    needed most: in enhancing its own platform integration and providing the
    API’s necessary for partners with expertise and dedication to other
    platforms to flourish in that space.</p>

    <p><a href="http://blog.hinshelwood.com/files/2012/09/image34.png"><img
    style="background-image: none; padding-top: 0px; padding-left: 0px; display:
    inline; padding-right: 0px; border-width: 0px;" title="Virtual Labs are
    required as the modern application is always connected"
    src="http://blog.hinshelwood.com/files/2012/09/image_thumb34.png"
    alt="Virtual Labs are required as the modern application is always
    connected" width="640" height="360" border="0" /></a><br /><strong>Figure:
    The modern application is always connected</strong></p>

    <p>These modern applications that we are envisaging and consumers (including
    your employees) are demanding are increasingly difficult to simulate as they
    are:</p>

    <ul>

    <li><strong>Always on</strong> – There is no safe time to down the
    servers</li>

    <li><strong>Accessible anywhere</strong> – Not just global, but any device,
    any platform</li>

    <li><strong>high scale data management</strong> – Today you have 10k users,
    tomorrow its 100k</li>

    <li><strong>Constantly evolving</strong>&nbsp; - You will be updating
    frequently. At least every 30 days..</li>

    </ul>

    <p>Enabling these traits successfully without inherent abilities internally
    is not just tough, it is an impossible challenge.</p>

    <h3 class="label-problem">The Problems that Virtual Labs solve</h3>

    <p>There are many issue that Engineering and Operations face on a near daily
    basis that are massively wasteful and that we should be able to at least
    alleviate with a clever application of existing and mature technology,
    however that technology is vastly complex and differs wildly in
    implementation.</p>

    <ul>

    <li>Plethora of instances</li>

    <li>False Positives</li>

    <li>Automation maintenance</li>

    </ul>

    <p>Lets look at each of these in turn.</p>

    <h4 class="label-problem">Problem: Plethora of instances</h4>

    <p>The number of instances that one is required to make available at any one
    time may be extremely prohibitive for even large organisations; thus
    inflating the cost of development beyond all sense with the additional
    equipment and manpower required. If you deploy thick clients to users
    desktops you may additionally have some varied lag in when those users
    update to the latest version. This may require that you support more than
    one version of your systems at a time; and it does not stop there. Lets
    imagine that you support <strong>vCurrent</strong> and
    <strong>vLast</strong> but lets say that you have one large customer still
    on <strong>v</strong><a
    href="http://www.urbandictionary.com/define.php?term=shonky"
    target="_blank"><strong>Shonkie</strong></a> then we have 3 environments we
    need to be able to deploy and test for. What if two of your
    <strong>vCurrent</strong> customers have special and specific hotfixes (Call
    them <strong>vCurrent+FlavourA</strong> and
    <strong>vCurrent+FlavourB</strong>) for their wacky systems and while these
    hotfixes are just baked into <strong>vNext</strong> you still need to find
    out when a bug was introduced and how far reaching it is… that's now 6
    environments… and we have not even started to count what we need for the
    Development Team and what about that new patch was in the news breaking
    everyone's software.</p>

    <ol>

    <li>Time spent wiping and reinstalling environments</li>

    <li>Time spent waiting for environments</li>

    </ol>

    <p>Not only is this a nightmare for the Development Teams it makes your
    Operations teams have heart attacks and your customers unhappy with the time
    it takes to get that new version ready..</p>

    <h4 class="label-problem">Problem: False Positives</h4>

    <p>An issue that you can run into pretty early on, depending on the number
    of testers that you have, is that of “false positives”. False positives are
    things that look like a bug to Tester A, but it is in fact the result of an
    action by Tester B whom is testing in the same environment, neither of which
    are aware of the issue. You then have two distinct bugs to investigate, plan
    and ultimately one will get fixed before the other leaving a developer
    flummoxed around trying to reproduce a bug that no longer exists. These
    collisions can multiply exponentially as the number of testers
    increases.</p>

    <p>There are a number of areas of waste here:</p>

    <ol>

    <li>More than one team member is spending time documenting a bug</li>

    <li>There may be some investigation by the team to figure out how big the
    problem is</li>

    <li>Inclusion and understanding of the product owner to effectively order
    this on the backlog</li>

    <li>Development Team time in fixing and validating the problem</li>

    </ol>

    <p>In the initial bug instance there may be a solid linear resolution of the
    engineer and tester working together to fix the issue. Additional incidental
    bugs however can result is substantial waste as the engineer and testers
    struggle to reproduce a bug that no-longer exists and prove beyond doubt
    that it does not. Proving a negative is next to impossible.</p>

    <h4 class="label-problem">Problem: Automation maintenance</h4>

    <p>A big issue is the time it takes to create automation and more than that,
    the time it takes to maintain it once it has been created. The time that it
    takes to create an automation should be … well… automatic, but the
    engineering effort that needs to be put into making your automation work
    against multiple environments can be immeasurable. This substantial effort
    includes parameterising your data, parameterising your environmental
    configuration and re-doing / updating everything when your software changes,
    which if at least every 30 days in the modern lifecycle. Most automation
    tools allow you to easily generate your automation, but they then force you
    to spend more effort maintaining that automation with far more skilled
    workers than you ever envisioned.</p>

    <p>There are many external factors that can render current automation
    efforts ineffectual and expensive:</p>

    <ol>

    <li>Multiple data sets that require post generation parameterisation of your
    automated tests</li>

    <li>Changes in environments and configurations between test runs</li>

    <li>New features that invalidate tests</li>

    </ol>

    <p>While we can never get away from having to redo much of our automation
    when the product that we are automating changes, we can at least prevent the
    need to cater for environmental differences that may include DNS, IP
    Addresses and accounts through ought your entire stack.</p>

    <h3 class="label-integration">Integration Points for Virtual Labs</h3>

    <p>There are three main integration points for any Virtual Lab environment
    to weave itself into the Visual Studio Team Foundation Server systems. We
    start with Creation move on to Deployment and end up at Testing.</p>

    <p><a
    href="http://blog.hinshelwood.com/files/2012/09/virtual-labs-in-the-modern-application-lifecycle-workflow.png"><img
    style="background-image: none; padding-top: 0px; padding-left: 0px; display:
    inline; padding-right: 0px; border-width: 0px;" title="Virtual Lab
    Integration points with Visual Studio 2012"
    src="http://blog.hinshelwood.com/files/2012/09/image_thumb35.png"
    alt="Virtual Lab Integration points with Visual Studio 2012" width="640"
    height="297" border="0" /></a><br /><strong>Figure: Virtual Lab Integration
    points</strong></p>

    <p>In each of these flows of integration there are three levels that the
    vendors can achieve. The first two already exist but the last would require
    some additional API’s in the product to support. One of the reasons that the
    team has not built these in is that there are currently no partners trying
    to integrate at this level.</p>

    <p><a href="http://blog.hinshelwood.com/files/2012/09/image36.png"><img
    style="background-image: none; padding-top: 0px; padding-left: 0px; display:
    inline; padding-right: 0px; border-width: 0px;" title="Virtual Labs are part
    Team Foundation Server Overview"
    src="http://blog.hinshelwood.com/files/2012/09/image_thumb36.png"
    alt="Virtual Labs are part Team Foundation Server Overview" width="640"
    height="341" border="0" /></a><br /><strong>Figure: Team Foundation Server
    Overview</strong></p>

    <p>Conversely partners need to know what the goal of integration is in order
    to support modern application development so that they can rise to the
    challenge and encourage the product team to prioritise those PBI’s that
    achieve these capabilities.</p>

    <h4 class="label-integration">Integration Level 1 (Create | Deploy |
    Test)</h4>

    <p>The first stage can&nbsp; be achieved by any partner in the
    virtualisation space already. In fact there are a number of partners that
    have started to even provide level 2 support and still more that provide
    support for #3 outside of Microsoft Test Manager. However we want to be able
    to use Test Professional’s Lab Manager and Test Manager to orchestrate and
    control all of these things. There are some configurations that would by
    necessity, as one would already have to do with load tests, be outside of
    the tool although the day-to-day work should be in the tool.</p>

    <p>At this level partners would allow a user to:</p>

    <ol>

    <li><strong>Create</strong> – Create environments on-demand</li>

    <li><strong>Deployment</strong> – Deploy their software to these
    environments</li>

    <li><strong>Testing</strong> – Perform tests from these
    environments<!--EndFragment--></li>

    </ol>

    <p>In #3 above the provider would be able to open a couple of ports to allow
    the installation and use of Microsoft Test Manager from inside of these
    environments to push the results of the manual testing back to Team
    Foundation Server. These are all things that do not require the partner to
    write a single line of integration for.</p>

    <h4 class="label-integration">Integration Level 2 (Creation Automation |
    Deployment Automation&nbsp; | Testing Automation)</h4>

    <p>Once you have the ability to perform the first set of create, deploy and
    test we can then move onto the automation of those capabilities. We now want
    to be able to use the orchestration capabilities of workflow within Team
    Foundation Build to automate the process of spinning up new virtual
    environments and even deploying ones software to those environments so that
    I do not need to be present or interact to come into the office in the
    morning with a deployed and working environment.</p>

    <ol>

    <li><strong>Create Automation</strong> – Provide build activities to allow
    creation</li>

    <li><strong>Deployment Automation</strong> – Provide build activities for
    deployment</li>

    <li><strong>Testing Automation</strong> – provide activities for test
    orchestration</li>

    </ol>

    <p>To achieve this the partner can leverage the capabilities of Team
    Foundation Build provided by Windows Workflow and create Activities that can
    be slotted into a .xaml build workflow to provide the automation required.
    And advanced solution from a partner would include full build workflow
    templates for users to just pick up and use. As part of enabling the
    deployment automation of #2 the likelihood is that it would be a short leap
    to the automated testing of #3 as the technology used is identical.</p>

    <p>While the partner would need to invest some not insignificant development
    effort in providing a robust set of Windows Workflow Activities and Build
    Automation Templates all of the API’s and capabilities are built into the
    product for them to take advantage of this.</p>

    <p><small>note: The automatic installation capabilities of MTM and Lab
    Management currently rely on the “File and Print Sharing” API’s in Windows
    to enable some of the automation. This will not work in the cloud and it is
    likely that the product team is looking to replace much of this
    functionality with purpose-built custom extensible framework.</small></p>

    <p><small>note: Some partners are providing awesome third-party automation
    tooling that can simulate many users accessing your application. These tools
    are outside of the Virtual Labs topic but provide tremendous value to the
    subscribers.</small></p>

    <h4 class="label-integration">Integration Level 3 (Creation via Lab
    Management| Deployment by Lab Management&nbsp; | Testing via Microsoft Test
    Manager)</h4>

    <p>The third level of integration is, as you can imagine, the tightest of
    all and would provide the users with a seamless experience whither they are
    using Hyper-v or some other services as the virtualisation platform. There
    are many value adds that the individual partners can provide and many of the
    customers just want things to work out-of-the-box before they take on that
    additional functionality.</p>

    <ol>

    <li><strong>Create from Test Manager</strong>– Provide the MTM hooks to
    allow it to spin-up and configure your environments</li>

    <li><strong>Deploy from Test Manager</strong> – Allow user to deploy a
    version of their software directly from MTM</li>

    <li><strong>Testing from Test Manager</strong> – Allow users to connect to
    your environment from MTM and run manual tests</li>

    </ol>

    <p>The only currently supported virtualisation technology underpinning Lab
    Manager is Hyper-V, but with the push towards cloud support it does not take
    a stretch of the imagination to believe that the product team are working to
    allow support for Azure. In working on this we now no longer have a single,
    but two interchangeable layers between on-premises and cloud which to me
    means that the API’s required to have any underlying infrastructure
    supported would need to exist. This would then open the way for partners to
    create support for Amazon AWS or Rackspace Cloud and indeed allow for first
    level support of automation for partners that currently support scale out
    testing and infrastructure options.</p>

    <h3 class="label-solution">Solution: Hyper-V (OOB)</h3>

    <p>The implementation of Lab Management that comes out of the box is with
    Hyper-V. This is designed for teams building software that is deployed
    locally on Microsoft technologies. For most teams it will suit there needs
    even if they are used to implementing VM Ware as this new environment is
    dedicated to the development teams. You would not expect there to be a copy
    of TFS that runs on Oracle <img class="wlEmoticon wlEmoticon-smile"
    src="http://blog.hinshelwood.com/files/2012/09/wlEmoticon-smile2.png"
    alt="Smile" /></p>

    <p>The integration of Lab Management and Hyper-V from the product team also
    augments many of the base capabilities to</p>

    <ul>

    <li><strong>Creation</strong> – Our environments are packages with many
    components</li>

    <li><strong>Snapshot</strong> – A point in time across the board</li>

    <li><strong>Deployment</strong> – Getting our build output into play</li>

    </ul>

    <p>There are additional capabilities provided by the Test Agents and Build
    Agents of Team Foundation Server but they are not specific to the Hyper-V
    integration. Indeed you can create “environments” for Lab Management from
    what Lab Management calls “physical” machines but more accurately is made up
    of “Unmanaged” machines.</p>

    <h3 class="label-solution">Solution: Cloudshare</h3>

    <p>CloudShare are providing the ability to spin up infrastructure and
    environments for your development &amp; testing needs very quickly with
    preconfigured environments. These environments may be used for building,
    unit-testing or functional testing via TFS Lab Manager that allow you to
    integrate their environments with your local workflow.</p>

    <p>CloudShare specialise in SharePoint environments and with the new
    features coming in Visual Studio 2012 Team Foundation Server Update 1 for
    CodedUI and Manual Testing in SharePoint 2010 their solution becomes even
    more relevant. They are currently only offering:</p>

    <ul>

    <li><strong>Creation</strong> – Manually create environments</li>

    <li><a
    href="http://blog.cloudshare.com/2012/06/18/using-tfs-service-preview-for-sharepoint-team-development-with-cloudshare/"
    target="_blank"><strong>Manual Deployment</strong></a> – Deploy from Visual
    Studio only</li>

    <li><strong>Manual Testing</strong> – Use Microsoft Test Manager (MTM) to
    perform tests</li>

    <li><strong>Automated Test</strong> – Allow automated tests to be run in
    Visual Studio</li>

    </ul>

    <p>These are all currently “level 1” integration features and I am looking
    forward to tighter integration coming from CloudShare in the future.</p>

    <h3 class="label-conclusion">Conclusion</h3>

    <p>In order to continuously monitor the progress of the project we need to
    be able to auto-magically build and deploy our software to multiple elastic
    environments that are then tested before a human being pulled in to either
    fix an issue or move forward with the known working build. The only way to
    achieve this is to make software available to Development Teams using
    virtual images that collect all of the data required to not only monitor the
    health of our project constantly, but also to have all of the data to hand
    when a rich actionable bug needs to be created.</p>

    <p>This allows us to integrate both the Development and Operations teams to
    achieve a regularly high velocity while simultaneously reducing the mean
    time to repair and the operations cycle time. But what does that give us…
    well it allows us to build more software, faster with a higher built-in
    quality with less technical debt dragging us down.</p>

    <ul>

    <li><strong>Hyper-V</strong> from Microsoft</li>

    <li><a href="http://www.cloudshare.com/"
    target="_blank"><strong>Cloudshare</strong></a></li>

    <li><strong>Lab Manager</strong> from VMWare</li>

    <li><strong>AWS</strong> from Amazon</li>

    <li><strong>Azure</strong> from Microsoft</li>

    </ul>

    <p>I hope that in the near future all of the products above will be able to
    be plugged into Visual Studio 2012 Team Foundation Server’s Lab Management
    capability to make them seamless to the development teams. I want to be able
    to create an environment in Lab Manager and have the backing store be any of
    the above services.</p>

    <p>Are you ready to rise to the challenge of building modern
    applications?</p>
  - ''
  post_id: '8803'
  post_date: '2012-09-21 22:22:14'
  post_date_gmt: '2012-09-22 05:22:14'
  post_modified: '2012-09-21 22:22:14'
  post_modified_gmt: '2012-09-22 05:22:14'
  comment_status: open
  ping_status: open
  post_name: virtual-labs-in-the-modern-application-lifecycle
  status: publish
  post_parent: '0'
  menu_order: '0'
  post_type: post
  post_password: ''
  is_sticky: '0'
  category: {}
  postmeta:
  - meta_key: authorsure_include_css
    meta_value: ''
  - meta_key: _yoast_wpseo_linkdex
    meta_value: '92'
  - meta_key: _edit_last
    meta_value: '3'
  - meta_key: _views_template
    meta_value: '0'
  - meta_key: _yoast_wpseo_focuskw
    meta_value: virtual labs
  - meta_key: _yoast_wpseo_title
    meta_value: Virtual Labs in the modern application lifecycle
  - meta_key: _yoast_wpseo_metadesc
    meta_value: >-
      Virtual Labs in the modern application lifecycle provide an abstraction
      layer between the infrastructure implementation and the engineering teams.
  - meta_key: dsq_thread_id
    meta_value: '852452577'
  - meta_key: _thumbnail_id
    meta_value: '8801'
  - meta_key: authorsure_include_css
    meta_value: ''
  - meta_key: _wpbitly
    meta_value: http://nkdalm.net/19AjmkP
  - meta_key: _jetpack_related_posts_cache
    meta_value: >-
      a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1473368898;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:10372;}i:1;a:1:{s:2:"id";i:9469;}i:2;a:1:{s:2:"id";i:9308;}}}}
  - meta_key: _wpghs_github_path
    meta_value: _posts/2012-09-21-virtual-labs-in-the-modern-application-lifecycle.md
  - meta_key: _sha
    meta_value: ''
  - meta_key: _wpml_media_has_media
    meta_value: '1'
  - meta_key: _tribe_ticket_capacity
    meta_value: '0'
  - meta_key: _tribe_ticket_version
    meta_value: 4.12.1.2
  - meta_key: ekit_post_views_count
    meta_value: '993'
  comment:
  - comment_id: '1410'
    comment_author: >-
      Virtual Labs in the modern application lifecycle | Visual Studio ALM |
      Scoop.it
    comment_author_email: ''
    comment_author_url: >-
      http://www.scoop.it/t/visual-studio-alm/p/2779092835/virtual-labs-in-the-modern-application-lifecycle
    comment_author_IP: 89.30.105.121
    comment_date: '2012-09-24 07:51:04'
    comment_date_gmt: '2012-09-24 14:51:04'
    comment_content: >-
      [...] In the world of modern application development we have many more
      moving parts than we ever did before and it has become increasingly
      difficult for organisations to effectively simulate their environments
      with virtual labs.&nbsp; [...]
    comment_approved: '1'
    comment_type: pingback
    comment_parent: '0'
    comment_user_id: '0'
    commentmeta:
    - meta_key: akismet_result
      meta_value: 'false'
    - meta_key: akismet_history
      meta_value: >-
        a:4:{s:4:"time";s:13:"1348498266.23";s:7:"message";s:28:"Akismet cleared
        this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}
    - meta_key: akismet_history
      meta_value: >-
        a:4:{s:4:"time";s:13:"1348500820.64";s:7:"message";s:46:"MrHinsh changed
        the comment status to
        approved";s:5:"event";s:15:"status-approved";s:4:"user";s:7:"MrHinsh";}
  - comment_id: '1411'
    comment_author: Visual Studio ALM links 39/2012
    comment_author_email: ''
    comment_author_url: >-
      http://www.codewrecks.com/blog/index.php/2012/09/28/visual-studio-alm-link-392012/
    comment_author_IP: 173.248.132.35
    comment_date: '2012-09-28 13:17:09'
    comment_date_gmt: '2012-09-28 20:17:09'
    comment_content: '[...] Virtual Labs in the modern application lifecycle [...]'
    comment_approved: '1'
    comment_type: pingback
    comment_parent: '0'
    comment_user_id: '0'
    commentmeta:
      meta_key: akismet_history
      meta_value: >-
        a:4:{s:4:"time";s:13:"1348863943.82";s:7:"message";s:46:"MrHinsh changed
        the comment status to
        approved";s:5:"event";s:15:"status-approved";s:4:"user";s:7:"MrHinsh";}
  - comment_id: '1412'
    comment_author: Quality enablement with Microsoft Visual Studio 2012
    comment_author_email: ''
    comment_author_url: >-
      http://blog.nwcadence.com/quality-enablement-with-microsoft-visual-studio-2012/
    comment_author_IP: 66.175.212.70
    comment_date: '2013-05-01 19:23:13'
    comment_date_gmt: '2013-05-01 18:23:13'
    comment_content: '[...] Virtual labs in the modern application lifecycle [...]'
    comment_approved: '1'
    comment_type: pingback
    comment_parent: '0'
    comment_user_id: '0'
    commentmeta:
    - meta_key: akismet_result
      meta_value: 'false'
    - meta_key: akismet_history
      meta_value: >-
        a:4:{s:4:"time";d:1367432593.449054;s:7:"message";s:28:"Akismet cleared
        this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}
    - meta_key: akismet_history
      meta_value: >-
        a:4:{s:4:"time";d:1367438468.820405;s:7:"message";s:46:"MrHinsh changed
        the comment status to
        approved";s:5:"event";s:15:"status-approved";s:4:"user";s:7:"MrHinsh";}
