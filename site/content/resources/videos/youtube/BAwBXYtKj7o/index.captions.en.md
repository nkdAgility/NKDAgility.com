Automated testing is extremely important to our ability to use modern software engineering to benefit our organization and increase our profit, increase our margins, increase our capability, and deliver better quality, higher value software to our customers. 

Automated testing comes in lots of different flavours, and I'm definitely going to stretch the term automated testing maybe from your traditional concept. One of the things that automated testing does is it reduces human errors. You would think I used to teach a training class; I still have it on my list of things for manual testers to use as your DevOps test tools. We had labs in it. You would think that if there was one group of people that were awesome at following a set of steps and validating whether they worked or not, you would think that a group of testers would be that magical group of people that would be able to do that. 

It's absolutely not the case. Most of the groups that were doing the labs failed to follow the steps and resulted in the lab not working. This lab doesn't work, right? And it's like, yeah, it does. Did you follow all the steps? Yes, yes, yes, we followed all the steps. Then you sit with them, and they walk through it, and I'm like, you missed step four. You didn't do step four, or you didn't do the second part of step four, or whatever it is, right? You didn't follow the instruction. 

This is just a human thing; this is not an assassination attempt on testers. It's just how humans work, right? So you cannot expect somebody to follow a set of steps and do it the same every time. That's not how humans function. That's how computers function. So we want to take those things that make sense and convert them into automated tests. 

Now, we're not looking for a particular level of code coverage, although no code coverage is probably bad. Chasing code coverage is always a bad idea because you'll just have lots of people writing terrible tests that get you good code coverage but don't actually validate your product, right? So don't chase code coverage or test coverage, but it is a way for us to get faster feedback. 

We want to have fast-running automated tests that we can validate the changes that we make on a continuous basis. TDD results in some of those, right? Some tests out of TDD are like that. Most tests out of TDD validate that at least the product does what the software engineer intended it to do and validates that we've got an architecture that probably is a little bit better. 

That's hopefully part of that testing mode, but the value in automated testing is it happens the same every time. You do need to balance this idea of test infrastructure, right? Because when we write test automation, we have a body of tests, and whenever we make a change to our product, it's going to have an impact on those tests. 

There used to be a great feature in Azure DevOps that had something called test impact analysis, and you could make a change in the code, and it would tell you exactly which code paths had changed and tell you which tests were impacted. I think there were a lot of false negatives, which is why it's not well thought of, but it was a great idea, right? A great idea. How do we know what tests we need to run? Well, let's look at what's changed and what the tests hit, and are we missing something, and which tests need to be rerun in order to reduce your test matrix? 

But because that fundamentally doesn't work because of complexity, right? That's what got in the way: the complexity of software engineering. We need to run them all, which means they all need to be super fast. We need unit tests, not end-to-end tests, not integration tests. We need unit tests that run really, really quickly and thousands of them in milliseconds. 

The Azure DevOps team moved from long-running end-to-end tests to fast-running unit tests and took their test strategy, their test infrastructure, from 72 hours down to 3 and a half minutes almost to run their entire test infrastructure. That's what you're looking to be able to do, and there's something like between 60,000 and 100,000 tests being run to validate that their product still works. 

That's the story that you're looking for. You're looking for small, lean, discrete tests that don't have an impact across the entire platform so that when you make a change in this part of the system, you only need to change the tests in that part of the system. All the other tests should still pass because you've not broken what they're expecting in other parts of the system, and it gives you a good indication. 

So having this tight test infrastructure, shifting left as much as you can, can and automating everything. The phrase I usually say is if it can be automated, it should be automated, and if it can't be automated, it should be refactored so that it can, right? Automate everything. You should not have any manual steps between developer cutting code and production. 

The only thing that I'd say was a valid place where you put a human between those things is maybe an approval, but I would prefer for those approvals to be automated. Right? On what basis does this human decide whether we're a go or no-go for release? Well, they look at this data. Well, we can automate that. They look at the calendar, and they only do it on these days. Well, we can look at that. We can say we only release on Monday mornings, right, to give us maximum amount of time to deal with any problems. 

Never release on Friday; don't do that. CL strike did that; don't do that. We can do all of those things. We can automate everything so that we have that engineering excellence, modern software engineering excellence built into our entire story so that we can then spend the time that we would have spent doing all those things manually and fixing all those problems focusing on delivering the value that's going to generate the revenue that we need to grow and create more. 

That's what we should be focusing on, and test automation is a huge part of that to reduce the number of problems that make it through to production, to reduce the amount of time it takes to detect that you've injected problems into the system. We can help you create those strategies, build that engineering excellence within your organization, and ultimately build better.