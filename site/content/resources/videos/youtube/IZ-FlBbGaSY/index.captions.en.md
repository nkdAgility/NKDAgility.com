If we want to improve the quality of our product and reduce risk, part of our automation story is going to be CI/CD pipelines. It's worth noting that most teams don't use CI/CD for CI/CD; they use it for an automated build. I see very few teams applying engineering excellence and doing CI/CD as it's intended to be done.

Just to clarify a little bit, continuous integration is coupled with mainline branching. It's not integrated if it's not in the mainline with the rest of your code. So if you've got a CI, a continuous integration on a separate branch, that's not actually a CI; that's just a continuous build on your separate branch, which is great. Definitely have that, but we want continuous integration. We want to be continuously pulling things into the one true version so we have fewer and fewer integration problems. We have fewer and fewer other problems coming off that because we're having to support multiple versions of our product.

If you've got test-live in branches, you're just fundamentally doing it wrong. You might have an older product; I definitely don't judge the decisions that led to that in the past. You might have made that choice 20 years ago in your product, but you shouldn't be making that choice today. Dev-test-live with branches? No product anywhere should be making that choice today. We should be doing continuous integration and continuous delivery. Continuous integration is where you have mainline branching and things are continuously integrating into that mainline branch. Everything, all the work of all the engineers that are working on your product, are continuously integrated every day.

Google is notorious for this one. They have one source control repository for the whole company. Every product everywhere in the company is on that one main line. That's a little bit extreme; that's a mono repo. But at least for a product, you want to have that mainline branching model where you're continuously integrating every day. You should not—I would object to a branch that's around for longer than a day. I'd strenuously object to a branch that's around for more than a couple of days. I'm not saying that they wouldn't happen; it's possible, but I strenuously object.

Where people are adding new things, adding new capability, branches shouldn't exist for very long. That's CI. Continuous integration, continuous delivery is when it hits the main line; it's going to production. Continuous delivery is not "I'm continuously delivering to my test environment"; it's "I'm continuously delivering to production to real users." Now, you might use a ring-based deployment model where you're protecting and limiting the blast radius of any problems behind an audience. Perhaps it could be audience-based rings that enable you to have your high-risk customers in a later ring, so you find the problems first with lower-risk customers.

But continuous delivery—the delivery part in continuous delivery—is production. It should be real users really using your product. So if you're doing continuous delivery, you should be seeing every commit to the main repo or a particular branch. Let's call it a branch; it could be called main, could be called master, could be called HK, whatever it's going to be called, it ends up in production. That's where people continuously integrate. So you CI into that, and then you CD from there to production.

Most teams and most organisations don't seem to do that. They say they're doing CI/CD, but they're just using the terminology and the tools that are part of it to do something else, which is just an automated build, which is also fine. You've got to have the right technology for the right thing. I recommend CI/CD; I recommend continuous integration, mainline branching, and continuous delivery into production.

For example, on products that I use, that I build, I might not use true CD. I think I'm almost there; I'm not quite there. I think it's a little bit too much risk for me because of my ability to test. But I continuously integrate to main, and it ships to production. I have CD on main; it ships to production as a preview, so the smaller number of users are controlling the blast radius. When I feel like the preview has enough telemetry to tell me that it's good, that I don't have a larger number of errors, I don't have people not being able to do the stuff that they're supposed to be able to do in the tool, when I have enough data, then I push the button and it rolls out to the next ring, which is everybody.

So I effectively have a two-ring system: a preview or CD system. Preview is a smaller subset of people that opt in to be using the preview version, and then everybody else. Sometimes, if somebody asks for a new thing, I'll get it into preview and I'll tell them it's in preview, and they can try it there and kick the tyres. I'll bring new stuff that's never been tried into preview; people will come and kick the tyres, and then it will only go to the rest of the world once it's been successful.

That's generally how Windows works; that's generally how Microsoft Teams works. Office 365—most of Microsoft products are now on a ring-based, audience-based deployment model, and that seems to be the most effective for services that you deliver to your customers. I think websites are a little bit different for commercial websites, but again, these are all things that we can talk about and figure out what the most effective model is. CD might not be the most effective model for you; CI might not be the most effective model. We might just want some automated builds.

Having the expertise to understand your product, understand its architecture, and understand what the business is trying to achieve with the product will help create that indication of how naked agility can support you in creating CI/CD or just some automation to enable you to be as effective as possible and increase your release frequency and reduce your cost of deployment.